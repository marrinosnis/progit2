[[r_git_refs]]
=== Αναφορές του Git

Αν θέλουμε να δούμε το ιστορικό του αποθετηρίου μας προσβάσιμο από μια υποβολή, ας πούμε `1a410e`, μπορούμε να τρέξουμε κάτι σαν `git log 1a410e`, για να δείξουμε αυτό το ιστορικό, αλλά πάλι χρειάζεται να θυμόμαστε ότι το `1a410e` είναι η υποβολή που θέλουμε να χρησιμοποιήσουμε ως σημείο εκκίνησης για το ιστορικό.
Αντιθέτως, θα ήταν ευκολότερο αν είχαμε ένα αρχείο στο οποίο μπορούμε να αποθηκεύσουμε την τιμή SHA-1 με ένα απλό όνομα, ώστε να μπορούμε να χρησιμοποιήσουμε αυτό το απλό όνομα και όχι την τιμή SHA-1.

Στο Git, αυτά ονομάζονται "`αναφορές`" ("`references`" ή "`refs`")· μπορούμε να βρούμε τα αρχεία που περιέχουν τις τιμές SHA-1 στον κατάλογο `.git/refs`.
Στο τρέχον έργο, αυτός ο κατάλογος δεν περιέχει αρχεία, αλλά περιέχει μια απλή δομή:

[source,console]
----
$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f
----

Για να δημιουργήσουμε μια νέα αναφορά που θα μας βοηθήσει να θυμόμαστε πού είναι η τελευταία μας υποβολή, τεχνικά μπορούμε να κάνουμε κάτι τόσο απλό όπως το εξής:

[source,console]
----
$ echo 1a410efbd13591db07496601ebc7a059dd55cfe9 > .git/refs/heads/master
----

Τώρα μπορούμε να χρησιμοποιήσουμε την αναφορά κεφαλής που μόλις δημιουργήσαμε αντί της τιμής SHA-1 στις εντολές Git:

[source,console]
----
$ git log --pretty=oneline master
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit
----

Καλό θα είναι να μην επεξεργαζόμαστε απευθείας τα αρχεία αναφορών; αντιθέτως, το Git παρέχει μία ασφαλέστερη εντολή εάν θέλουμε να ενημερώσουμε μια αναφορά, την `git update-ref`:

[source,console]
----
$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9
----

Αυτό βασικά είναι ένας κλάδος στο Git: ένας απλός δείκτης ή μια αναφορά στην κεφαλή μιας γραμμής εργασίας.
Για να δημιουργήσουμε έναν κλάδο πίσω στη δεύτερη υποβολή, μπορούμε να το κάνουμε το εξής:

[source,console]
----
$ git update-ref refs/heads/test cac0ca
----

Ο κλάδος μας θα περιέχει μόνο εργασίες από αυτήν την υποβολή και μετά:

[source,console]
----
$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Τώρα, η βάση δεδομένων του Git μοιάζει με αυτό:

.Αντικείμενα του καταλόγου του Git συμπεριλαμβάνομένων αναφορών κεφαλής κλάδου.
image::images/data-model-4.png[Αντικείμενα του καταλόγου του Git συμπεριλαμβάνομένων αναφορών κεφαλής κλάδου]

Όταν εκτελούμε εντολές όπως η `git branch <όνομα_κλάδου>`, το Git βασικά τρέχει αυτήν την εντολή `update-ref` για να προσθέσει τον αριθμό SHA-1 της τελευταίας υποβολής του κλάδου στον οποίο βρισκόμαστε σε οποιαδήποτε νέα αναφορά θέλουμε να δημιουργήσουμε.

[[r_ref_the_ref]]
==== Ο HEAD

Το ερώτημα τώρα είναι, όταν τρέχουμε την `git branch <όνομα_κλάδου>`, πώς γνωρίζει το Git τον αριθμό SHA-1 της τελευταίας υποβολής;
Η απάντηση είναι το αρχείο HEAD.

Το αρχείο HEAD είναι συμβολική αναφορά στον κλάδο στο οποίο βρισκόμαστε.
Με συμβολική αναφορά, εννοούμε ότι σε αντίθεση με μια κανονική αναφορά, δεν περιέχει γενικά μια τιμή SHA-1, αλλά έναν δείκτη σε μια άλλη αναφορά.

Ωστόσο σε μερικές σπάνιες περιπτώσεις το HEAD αρχείο μπορεί να περιέχει τις SHA-1 τιμές ενός Git αντικειμένου.
Αυτό γίνεται όταν ενημερώνουμε (checkout) μια ετικέτα, υποβολή, ή ένα απομακρυσμένο κλάδο, το οποίο βάζει το αποθετήριό μας σε μια κατάσταση https://git-scm.com/docs/git-checkout#_detached_head["αποκομμένος HEAD"^].

Εάν κοιτάξουμε το αρχείο, θα δούμε κάτι τέτοιο:

[source,console]
----
$ cat .git/HEAD
ref: refs/heads/master
----

Αν εκτελέσουμε την `git checkout test`, το Git ενημερώνει το αρχείο ώστε να φαίνεται ως εξής:

[source,console]
----
$ cat .git/HEAD
ref: refs/heads/test
----

Όταν εκτελούμε την `git commit`, δημιουργεί το αντικείμενο υποβολής, ορίζοντας τον γονέα του αντικειμένου υποβολής να είναι όποια τιμή SHA-1 δείχνει η αναφορά στον HEAD.

Μπορούμε επίσης να επεξεργαστούμε χειροκίνητα αυτό το αρχείο, αλλά και πάλι υπάρχει μια ασφαλέστερη εντολή: `git symbolic-ref`.
Μπορούμε να διαβάσουμε την τιμή του HEAD μας μέσω αυτής της εντολής:

[source,console]
----
$ git symbolic-ref HEAD
refs/heads/master
----

Μπορούμε επίσης να ορίσουμε την τιμή του HEAD:

[source,console]
----
$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test
----

Δεν μπορούμε να ορίσουμε μια συμβολική αναφορά εκτός του καταλόγου refs:

[source,console]
----
$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/
----

==== Ετικέτες

Μόλις ολοκληρώσαμε τη συζήτηση για τους τρεις κύριους τύπους αντικειμένων του Git (_blobs_, _δέντρα_ και _υποβολές_), αλλά υπάρχει ένας τέταρτος.
Το αντικείμενο _ετικέτα_ (tag) μοιάζει πολύ με ένα αντικείμενο υποβολής —περιέχει μία ταμπέλα, μια ημερομηνία, ένα μήνυμα και έναν δείκτη.
Η κύρια διαφορά είναι ότι ένα αντικείμενο ετικέτας γενικά δείχνει σε υποβολή παρά σε δέντρο.
Είναι σαν αναφορά κλάδου, αλλά δεν μετακινείται ποτέ —δείχνει πάντοτε την ίδια υποβολή, αλλά δίνει ένα πιο φιλικό όνομα.

Όπως αναλύθηκε στην ενότητα <<ch02-git-basics-chapter#ch02-git-basics-chapter>>, υπάρχουν δύο τύποι ετικετών: επισημειωμένοι (annotated) και ελαφριές (lightweight).
Μπορούμε να κάνουμε μια ελαφριά ετικέτα τρέχοντας κάτι σαν αυτό:

[source,console]
----
$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
----

Μία ελαφριά ετικέτα είναι ακριβώς και μόνον αυτό —μια αναφορά που δεν κινείται ποτέ.
Ωστόσο, μια επισημειωμένη ετικέτα είναι πιο περίπλοκη.
Αν δημιουργήσουμε μια επισημειωμένη ετικέτα, το Git δημιουργεί ένα αντικείμενο ετικέτας και στη συνέχεια γράφει μια αναφορά που δείχνει σε αυτήν και όχι απευθείας στην υποβολή.
Μπορούμε να το δούμε αυτό δημιουργώντας μια επισημειωμένη ετικέτα (χρησιμοποιώντας την επιλογή `-a`):

[source,console]
----
$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'
----

Εδώ είναι το αντικείμενο SHA-1 που δημιούργησε:

[source,console]
----
$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2
----

Τώρα, ας εκτελέσουμε την εντολή `git cat-file -p` στην τιμή SHA-1:

[source,console]
----
$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon <schacon@gmail.com> Sat May 23 16:48:58 2009 -0700

test tag
----

Παρατηρούμε ότι το αντικείμενο δείχνει στην τιμή SHA-1 της υποβολής που έχουμε επισημάνει.
Επίσης παρατηρούμε ότι δεν είναι απαραίτητο να δείχνει σε μια υποβολή· μπορούμε να βάλουμε ετικέτα σε οποιοδήποτε αντικείμενο Git.
Στον πηγαίο κώδικα Git, για παράδειγμα, ο συντηρητής έχει προσθέσει το δημόσιο κλειδί GPG ως αντικείμενο blob και έπειτα του προσάρτησε μία ετικέτα.
Μπορούμε να δούμε το δημόσιο κλειδί τρέχοντας αυτό σε έναν κλώνο του Git αποθετηρίου :

[source,console]
----
$ git cat-file blob junio-gpg-pub
----

Το αποθετήριο του πυρήνα Linux δεν διαθέτει κανένα αντικείμενο ετικέτας που να δείχνει σε υποβολή —η πρώτη ετικέτα που δημιουργήθηκε δείχνει στο αρχικό δέντρο της εισαγωγής του πηγαίου κώδικα.

==== Απομακρυσμένες αναφορές

Ο τρίτος τύπος αναφοράς που θα δούμε είναι μια απομακρυσμένη αναφορά.
Εάν προσθέσουμε ένα απομακρυσμένο αποθετήριο και ωθήσουμε σε αυτό, το Git αποθηκεύει την τιμή που ωθήσαμε τελευταία σε αυτό το απομακρυσμένο αποθετήριο για κάθε κλάδο στον κατάλογο `refs/remotes`.
Για παράδειγμα, μπορούμε να προσθέσουμε ένα απομακρυσμένο αποθετήριο που ονομάζεται `origin` και να ωθήσουμε τον `master` κλάδο μας σε αυτό:

[source,console]
----
$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -> master
----

Στη συνέχεια, μπορούμε να δούμε πώς ήταν ο κλάδος `master` στο απομακρυσμένο αποθετήριο `origin` την τελευταία φορά που επικοινωνήσαμε με τον διακομιστή, ελέγχοντας το αρχείο `refs/remotes/origin/master`:

[source,console]
----
$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949
----

Οι απομακρυσμένες αναφορές διαφέρουν από τους κλάδους (`refs/heads`) κυρίως επειδή θεωρούνται μόνο για ανάγνωση.
Μπορούμε να κάνουμε `git checkout` σε μία απομακρυσμένη αναφορά, αλλά το Git ποτέ δεν θα κάνει συμβολική αναφορά του HEAD σε μία, συνεπώς ποτέ δεν θα την ενημερώσουμε με μια εντολή `commit`.
Το Git τις διαχειρίζεται ως σελιδοδείκτες στην τελευταία γνωστή κατάσταση στην οποία βρίσκονταν εκείνοι οι κλάδοι σε αυτούς τους διακομιστές.
