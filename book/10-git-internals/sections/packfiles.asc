=== Πακετάρισμα αρχείων

Ας επιστρέψουμε στη βάση δεδομένων των αντικειμένων για το δοκιμαστικό μας αποθετήριο Git.
Σε αυτό το σημείο, έχουμε 11 αντικείμενα —4 blobs, 3 δέντρα, 3 υποβολές και 1 ετικέτα:

[source,console]
----
$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # δέντρο 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # υποβολή 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # δέντρο 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # ετικέτα
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # υποβολή 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # δέντρο 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # υποβολή 1
----

Το Git συμπιέζει τα περιεχόμενα αυτών των αρχείων με το zlib και δεν αποθηκεύουμε πολλά, έτσι ώστε όλα αυτά τα αρχεία έχουν αθροιστικά μόνο 925 byte.
Θα προσθέσουμε μεγαλύτερο περιεχόμενο στο αποθετήριο για να δείξουμε ένα ενδιαφέρον χαρακτηριστικό του Git.
Για να το καταδείξουμε, προσθέτουμε το αρχείο `repo.rb` από τη βιβλιοθήκη Grit —πρόκειται για ένα αρχείο πηγαίου κώδικα 22K:

[source,console]
----
$ curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb > repo.rb
$ git add repo.rb
$ git commit -m 'added repo.rb'
[master 484a592] added repo.rb
 3 files changed, 709 insertions(+), 2 deletions(-)
 delete mode 100644 bak/test.txt
 create mode 100644 repo.rb
 rewrite test.txt (100%)
----

Αν κοιτάξουμε το δέντρο που προκύπτει, μπορούμε να δούμε την τιμή SHA-1 που έχει λάβει το αρχείο repo.rb για το αντικείμενο blob:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
----

Μπορούμε να χρησιμοποιήσουμε την `git cat-file` για να δούμε πόσο μεγάλο είναι αυτό το αντικείμενο:

[source,console]
----
$ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5
22044
----

Τώρα, ας δούμε τι συμβαίνει αν τροποποιήσουμε λίγο το αρχείο:

[source,console]
----
$ echo '# testing' >> repo.rb
$ git commit -am 'modified repo a bit'
[master 2431da6] modified repo.rb a bit
 1 file changed, 1 insertion(+)
----

Αν ελέγξουμε το δέντρο που δημιουργήθηκε από αυτήν την υποβολή, βλέπουμε κάτι ενδιαφέρον:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt
----

Το blob είναι τώρα ένα διαφορετικό blob, πράγμα που σημαίνει ότι αν και προσθέσατε μόνο μία γραμμή στο τέλος ενός αρχείου 400 γραμμών, το Git αποθηκεύει αυτό το νέο περιεχόμενο ως ένα εντελώς νέο αντικείμενο:

[source,console]
----
$ git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e
22054
----

Έχουμε δύο σχεδόν ταυτόσημα αντικείμενα 22K στον δίσκο μας.
Δεν θα ήταν ωραίο αν το Git μπορούσε να αποθηκεύσει ένα από αυτά πλήρως, αλλά το δεύτερο αντικείμενο μόνο ως το δέλτα μεταξύ αυτού και του πρώτου;

Ε, λοιπόν, μπορεί.
Η αρχική μορφή στην οποία το Git αποθηκεύει αντικείμενα στον δίσκο ονομάζεται _χαλαρή_ μορφή αντικειμένου.
Εντούτοις, περιστασιακά το Git ``πακετάρει'' αρκετά από αυτά τα αντικείμενα σε ένα μόνο δυαδικό αρχείο που ονομάζεται πακέτο (packfile) για να εξοικονομήσει χώρο και να είναι πιο αποδοτικό.
Το Git το κάνει αυτό εάν έχουμε πολλά χαλαρά αντικείμενα γύρω μας, αν εκτελέσουμε χειροκίνητα την εντολή `git gc` ή αν ωθήσουμε σε έναν απομακρυσμένο διακομιστή.
Για να δούμε τι συμβαίνει, μπορούμε να ζητήσουμε από το Git να συσκευάσει τα αντικείμενα καλώντας την εντολή `git gc`:

[source,console]
----
$ git gc
Counting objects: 18, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (18/18), done.
Total 18 (delta 3), reused 0 (delta 0)
----

Αν κοιτάξουμε στον κατάλογο των αντικειμένων μας, θα διαπιστώσουμε ότι τα περισσότερα αντικείμενά μας έχουν εξαφανιστεί και εμφανίστηκε ένα νέο ζευγάρι αρχείων:

[source,console]
----
$ find .git/objects -type f
.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/info/packs
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack
----

Τα αντικείμενα που παραμένουν είναι τα blob στα οποία δεν δείχνει καμία υποβολή —στην περίπτωση αυτή, τα ``what up, doc'' και ``test content'' που δημιουργήσαμε νωρίτερα.
Επειδή δεν τα προσθέσαμε ποτέ σε καμία υποβολή, θεωρούνται ότι εκκρεμή και δεν έχουν συσκευαστεί στο νέο μας πακέτο.

Τα άλλα αρχεία είναι το νέο πακέτο και ένα ευρετήριο.
Το πακέτο είναι μόνον ένα αρχείο που περιέχει τα περιεχόμενα όλων των αντικειμένων που έχουν αφαιρεθεί από το σύστημα αρχείων μας.
Το ευρετήριο είναι ένα αρχείο που περιέχει τις θέσεις σε byte των αντικειμένων σε αυτό το packfile ώστε η αναζήτηση ενός συγκεκριμένου αντικειμένου να γίνεται γρήγορα.

Το ωραίο είναι ότι αν και τα αντικείμενα στον δίσκο προτού εκτελέσουμε την `gc` ήταν συνολικά περίπου 22Κ σε μέγεθος, το νέο πάκο είναι μόνο 7K.
Έχουμε μειώσει τη χρήση του δίσκου κατά ⅔ επειδή πακετάραμε τα αντικείμενά μας.

Πώς το κάνει αυτό το Git;
Όταν το Git πακετάρει αντικείμενα, ψάχνει για αρχεία που έχουν παρόμοιο όνομα και μέγεθος  και αποθηκεύει μόνο τις διαφορές (deltas) από μια έκδοση του αρχείου στην επόμενη.
Μπορούμε να δούμε μέσα στο πακέτο και να δούμε τι έκανε το Git για να εξοικονομήσει χώρο.
Η εντολή `git verify-pack` μας δίνει τη δυνατότητα να δούμε τι ήταν συσκευάστηκε στο πακέτο:

[source,console]
----
$ git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12
69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167
80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319
43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464
092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610
702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756
d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874
fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132
deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178
d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1350
83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426
fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445
b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \
  b042a60ef7dff760008df33cee372b945b6e884e
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282
non delta: 15 objects
chain length = 1: 3 objects
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok
----

Εδώ, το blob `033b4`, το οποίο, ας θυμηθούμε, ήταν η πρώτη έκδοση του αρχείου repo.rb γίνεται αναφορά στο blob `b042a`, που ήταν η δεύτερη έκδοση του αρχείου.
Η τρίτη στήλη στην έξοδο είναι το μέγεθος του αντικειμένου στο πακέτο, ώστε να μπορούμε να δούμε ότι το `b042a` καταλαμβάνει 22Κ του αρχείου, αλλά το `033b4` καταλαμβάνει μόνο 9 byte.
Αυτό που είναι επίσης ενδιαφέρον είναι ότι η δεύτερη έκδοση του αρχείου είναι αυτή που είναι αποθηκευμένη άθικτη, ενώ η αρχική έκδοση αποθηκεύεται ως δέλτα —αυτό γίνεται επειδή πιθανότατα θα χρειαστούμε ταχύτερη πρόσβαση στην πιο πρόσφατη έκδοση του αρχείου .

Αυτό που είναι πραγματικά ωραίο είναι ότι μπορεί να ανασυσκευαστεί ανά πάσα στιγμή.
Το Git ξαναπακετάρει κατά καιρούς τη βάση δεδομένων μας αυτόματα, προσπαθώντας πάντα να εξοικονομήσει περισσότερο χώρο, αλλά μπορούμε επίσης να επανασυσκευάσουμε μη-αυτόματα οποιαδήποτε στιγμή τρέχοντας `git gc`.

