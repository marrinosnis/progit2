[[r_objects]]
=== Αντικείμενα του Git

Το Git είναι ένα σύστημα αρχείων διευθυνσιοδοτούμενο από το περιεχόμενο.
Εξαιρετικά.
Τι σημαίνει αυτό;
Σημαίνει ότι ουσιαστικά το Git είναι κατά βάση ένα απλό κατάστημα δεδομένων ζευγαριών κλειδιού-τιμής (key-value data store).
Μπορούμε να εισάγουμε οποιουδήποτε είδους περιεχόμενο στο Git αποθετήριο, για το οποίο το Git θα μας δώσει πίσω ένα μοναδικό κλειδί που μπορούμε να χρησιμοποιήσουμε για να επανακτήσουμε το περιεχόμενο ξανά.

Για να το επιδείξουμε, μπορούμε να χρησιμοποιήσουμε την εντολή διοχέτευσης `git hash-object`, η οποία λαμβάνει ορισμένα δεδομένα, τα αποθηκεύει στον κατάλογο `.git/objects` (η _βάση αντκειμένων_), και μας επιστρέφει το κλειδί στο οποίο αποθηκεύονται τα δεδομένα.

Αρχικά, αρχικοποιούμε ένα νέο αποθετήριο Git και βεβαιωνόμαστε ότι δεν υπάρχει τίποτα στον κατάλογο `objects`:

[source,console]
----
$ git init test
Initialized empty Git repository in /tmp/test/.git/
$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f
----

Το Git έχει αρχικοποιήσει τον κατάλογο `objects` και έχει δημιουργήσει τους υποκαταλόγους `pack` και `info` σε αυτόν, αλλά δεν έχει κανονικά αρχεία.
Τώρα, ας χρησιμοποιήσουμε την εντολή `git hash-object` για να φτιάξουμε ένα νέο αντικείμενο δεδομένων (data object) και χειροκινήτα θα το αποθηκεύσουμε στη βάση δεδομένων του Git:

[source,console]
----
$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4
----

Στην πιο απλή μορφή της, η εντολή `git hash-object` θα πάρει το περιεχόμενο που που δώσαμε σε αυτήν, και απλώς θα επιστρέψει ο μοναδικό κλειδί που _θα χρησιμοποιηθεί_ για να το αποθηκεύσουμε στην βάση δεδομένων του Git.
Το `-w` λέει στην εντολή να μην επιστρέψει απλώς το κλειδί, αλλά να αποθηκεύσει το αντικείμενο στη βάση δεδομένων.
Τέλος, η επιλογή `--stdin` λέει στην εντολή `git hash-object` να διαβάσει το περιεχόμενο από την stdin· αλλιώς, η εντολή θα περιμένει ένα όνομα αρχείου στο τέλος της εντολής που θα περιέχει το περιεχόμενο πυο θα χρησιμοποιηθεί.

Η έξοδος από την εντολή είναι ένα άθροισμα ελέγχου 40 χαρακτήρων.
Αυτός είναι ο αριθμός SHA-1 hash —ένα άθροισμα ελέγχου του περιεχομένου που αποθηκεύουμε συν μια κεφαλίδα, για την οποία θα μάθουμε σε λίγο.
Τώρα μπορούμε να δούμε πώς το Git έχει αποθηκεύσει τα δεδομένα μας:

[source,console]
----
$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

Αν δούμε πάλι τον κατάλογο `objects`, θα δούμε περιέχει ένα αρχείο για το νέο περιεχόμενο.
Αυτός είναι ο τρόπος με τον οποίο το Git αποθηκεύει αρχικά το περιεχόμενο —ως ένα μοναδικό αρχείο ανά τεμάχιο περιεχομένου, το οποίο ονομάζεται με το άθροισμα ελέγχου SHA-1 του περιεχομένου και την κεφαλίδα του.
Ο υποκατάλογος ονομάζεται με τους πρώτους 2 χαρακτήρες του SHA-1 και το όνομα αρχείου είναι οι υπόλοιποι 38 χαρακτήρες.

Μόλις έχουμε περιεχόμενο στη βάση δεδομένων αντικειμένων, μπορούμε να ελέγξουμε αυτό το περιεχόμενο με την εντολή `git cat-file`.
Αυτή η εντολή είναι ένα είδος ελβετικού σουγιά για την επιθεώρηση αντικειμένων Git.
Η επιλογή `-p` στην εντολή `cat-file` την καθοδηγεί να καταλάβει τον τύπο του περιεχομένου και να το εμφανίσει κατάλληλα:

[source,console]
----
$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content
----

Τώρα, μπορούμε να προσθέσουμε περιεχόμενο στο Git και να το τραβήξουμε πίσω ξανά.
Μπορούμε επίσης να το κάνουμε αυτό με περιεχόμενο σε αρχεία.
Για παράδειγμα, μπορούμε να κάνουμε κάποιο απλό έλεγχο εκδόσεων σε ένα αρχείο.
Αρχικά, δημιουργούμε ένα νέο αρχείο και αποθηκεύουμε τα περιεχόμενά του στη βάση δεδομένων μας:

[source,console]
----
$ echo 'version 1' > test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
----

Στη συνέχεια, γράφουμε νέο περιεχόμενο στο αρχείο και το αποθηκεύουμε ξανά:

[source,console]
----
$ echo 'version 2' > test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
----

Η βάση δεδομένων μας περιέχει τις δύο νέες εκδόσεις του αρχείου (καθώς και το πρώτο περιεχόμενο που αποθηκεύσαμε εκεί):

[source,console]
----
$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
----

Σε αυτό το σημείο, μπορούμε να σβήσουμε το τοπικό αντίγραφο του αρχείου `test.txt`, μετά να χρησιμοποιήσουμε το Git για να το επαναφέρουμε, από την βάση δεδομένων των αντικειμένων, στην πρώτη έκδοση του αρχείου:

[source,console]
----
$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt
$ cat test.txt
version 1
----

ή τη δεύτερη έκδοση:

[source,console]
----
$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt
$ cat test.txt
version 2
----

Αλλά πρέπει να θυμόμαστε το κλειδί SHA-1 για κάθε έκδοση του αρχείου μας δεν είναι πρακτικό· επιπλέον, δεν αποθηκεύουμε το όνομα αρχείου στο σύστημά μας —απλά το περιεχόμενο.
Αυτός ο τύπος αντικειμένου ονομάζεται _blob_.
Μπορούμε να βάλουμε το Git να μας πει τον τύπο οποιουδήποτε αντικειμένου στο Git, δεδομένου του κλειδιού του SHA-1, με την `git cat-file -t`:

[source,console]
----
$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob
----

[[r_tree_objects]]
==== Αντικείμενα δέντρων

Ο επόμενος τύπος που θα εξετάσουμε είναι το _δέντρο_, το οποίο λύνει το πρόβλημα της αποθήκευσης του ονόματος αρχείου και επίσης μας επιτρέπει να αποθηκεύσουμε μια ομάδα αρχείων μαζί.
Το Git αποθηκεύει το περιεχόμενο λίγο-πολύ όπως το σύστημα αρχείων του UNIX αλλά λίγο πιο απλοποιημένα.
Όλα τα περιεχόμενα αποθηκεύοντται ως αντικείμενα δέντρου και blob, με τα δέντρα να αντιστοιχίζονται στους καταλόγους UNIX και τα blob να αντιστοιχίζονται χονδρικά σε inodes ή περιεχόμενα αρχείων.
Ένα αντικείμενο δέντρου περιέχει μία ή περισσότερες καταχωρίσεις δέντρων, καθεμία από τις οποίες είναι η SHA-1 κρυπτογράφηση ένος blob ή ένός υποδέντρου με το σχετικό δικαιώμα πρόσβασης, τύπο και όνομα αρχείου.
Για παράδειγμα, το πιο πρόσφατο δέντρο ενός έργου μπορεί να μοιάζει με αυτό:

[source,console]
----
$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib
----

Η σύνταξη `master^{tree}` καθορίζει το αντικείμενο δέντρου στο οποίο δείχνει η τελευταία υποβολή στον κλάδο `master`.
Παρατηρούμε ότι ο υποκατάλογος `lib` δεν είναι blob αλλά ένας δείκτης σε ένα άλλο δέντρο:

[source,console]
----
$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb
----

[NOTE]
====
Δεδομένου τι κέλυφος (shell) χρησιμοποιούμε, μπορεί να συναντήσουμε σφάλματα όταν χρησιμοποιούμε την σύνταξη `master^{tree}`.

Στο CMD των Windows, ο `^` χαρακτήρας χρησιμοποιείται για διαφυγή, οπότε θα πρέπει να το διπλασιάσουμε για να το αποφύγουμε: `git cat-file -p master^^{tree}`.
Όταν χρησιμοποιούμε PowerShell, οι παραμέτροι που χρησιμοποιούν τους χαρακτήρες `{}`, πρέπει να μπαίνουν σε διπλά εισαγωγικά για να αποφύγουμε η μεταβλήτη να αναλυθεί λάθος: `git cat-file -p 'master^{tree}'`.

Όταν χρησιμοποιούμε ZSH, ο `^` χαρακτήρας χρησιμοποιείται για σφαιρική (globbing), οπότε πρέπει περικλύσουμε όλη την έκφραση σε διπλά εισαγωγικά: `git cat-file -p "master^{tree}"`.
====

Εννοιολογικά, τα δεδομένα που αποθηκεύει το Git είναι δυνατό να απεικονιστούν με κάτι τέτοιο:

.Απλή εκδοχή του μοντέλου δεδομένων του Git.
image::images/data-model-1.png[Απλή εκδοχή του μοντέλου δεδομένων Git]

Μπορούμε εύκολα να δημιουργήσουμε το δικό μας δέντρο.
Το Git δημιουργεί κανονικά ένα δέντρο λαμβάνοντας την κατάσταση του σταδίου καταχώρισης ή ευρετηρίου και γράφοντας μια σειρά από αντικείμενα δέντρων από αυτό.
Επομένως, για να δημιουργήσουμε ένα αντικείμενο δέντρου, πρέπει πρώτα να ορίσουμε ένα ευρετήριο βάζοντας μερικά αρχεία στο στάδιο καταχώρισης.
Για να δημιουργήσουμε ένα ευρετήριο με μια μοναδική καταχώρηση —την πρώτη έκδοση του αρχείου `test.txt`— μπορούμε να χρησιμοποιήσουμε την εντολή διοχέτευσης `git update-index`.
Χρησιμοποιούμε αυτήν την εντολή για να προσθέσουμε τεχνητά την παλαιότερη έκδοση του αρχείου `test.txt` σε ένα νέο στάδιο καταχώρισης.
Πρέπει να περάσουμε την επιλογή `--add` επειδή το αρχείο δεν υπάρχει ακόμη στο στάδιο καταχώρισής μας (για την ακρίβεια δεν έχουμε καν στάδιο καταχώρισης ακόμα, αφού δεν το έχουμε δημιουργήσει) και την `--cacheinfo` επειδή το αρχείο που προσθέτουμε δεν βρίσκεται στον κατάλογό μας αλλά βρίσκεται στη βάση δεδομένων μας.
Στη συνέχεια, καθορίζουμε το δικαίωμα πρόσβασης, τον SHA-1 και το όνομα αρχείου:

[source,console]
----
$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt
----

Σε αυτήν την περίπτωση, καθορίζουμε δικαίωμα πρόσβασης `100644`, που σημαίνει ότι είναι ένα κανονικό αρχείο.
Άλλες επιλογές είναι `100755`, πράγμα που σημαίνει ότι είναι ένα εκτελέσιμο αρχείο· και `120000`, που καθορίζει έναν συμβολικό σύνδεσμο.
Το δικαίωμα πρόσβασης λαμβάνεται από τα συνήθη δικαιώματα πρόσβασης του UNIX, αλλά είναι πολύ λιγότερο ευέλικτα —αυτά τα τρία δικαιώματα πρόσβασης είναι τα μόνα που ισχύουν για τα αρχεία (blobs) στο Git (για καταλόγους και υπομονάδες χρησιμοποιούνται άλλα δικαιώματα πρόσβασης).

Τώρα, μπορούμε να χρησιμοποιήσουμε την εντολή `git write-tree` για να γράψουμε το στάδιο καταχώρισης σε ένα αντικείμενο δέντρου.
Δεν χρειάζεται η επιλογή `-w` —η κλήση της `write-tree` δημιουργεί αυτόματα ένα αντικείμενο δέντρου από την κατάσταση του ευρετηρίου, αν το δέντρο δεν υπάρχει ακόμα:

[source,console]
----
$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt
----

Μπορούμε επίσης να επαληθεύσουμε ότι πρόκειται για ένα αντικείμενο δέντρου χρησιμοποιώντας την εντολή `git cat-file` που είδαμε προηγουμένως:

[source,console]
----
$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree
----

Θα δημιουργήσουμε τώρα ένα νέο δέντρο με τη δεύτερη έκδοση του `test.txt` και ένα νέο αρχείο:

[source,console]
----
$ echo 'new file' > new.txt
$ git update-index --cacheinfo 100644 \
  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
$ git update-index --add new.txt
----

Το στάδιο καταχώρισής μας διαθέτει τώρα τη νέα έκδοση του `test.txt` καθώς και το νέο αρχείο `new.txt`.
Γράφουμε αυτό το δέντρο (καταγράφοντας την κατάσταση του σταδίου καταχώρισης ή ευρετηρίου σε ένα αντικείμενο δέντρου) και βλέπουμε πώς φαίνεται:

[source,console]
----
$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Παρατηρούμε ότι αυτό το δέντρο έχει και τις δύο καταχωρήσεις αρχείων και ότι ο SHA-1 του αρχείου `test.txt` είναι ο SHA-1 του "`version 2`" από πριν (`1f7a7a`).
Για πλάκα θα προσθέσουμε το πρώτο δέντρο ως υποκατάλογο σε αυτό.
Μπορούμε να διαβάσουμε τα δέντρα που βρίσκονται στο στάδιο καταχώρισής μας καλώντας την `git read-tree`.
Σε αυτήν την περίπτωση, μπορούμε να διαβάσουμε ένα υπάρχων δέντρο στο στάδιο καταχώρισής μας ως υποδέντρο χρησιμοποιώντας την επιλογή `--prefix` με αυτή την εντολή:

[source,console]
----
$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt
----

Αν δημιουργούσαμε έναν κατάλογο εργασίας από το νέο δέντρο που μόλις γράψαμε, θα παίρναμε τα δύο αρχεία στο ανώτερο επίπεδο του καταλόγου εργασίας και έναν υποκατάλογο με όνομα `bak` που θα περιείχε την πρώτη έκδοση του αρχείου `test.txt`.
Μπορούμε να σκεφτόμαστε τα δεδομένα που περιέχει το Git για αυτές τις δομές ως εξής:

.Η δομή περιεχομένων των τωρινών δεδομένων μας στο Git.
image::images/data-model-2.png[Η δομή περιεχομένων των τωρινών δεδομένων μας στο Git]

[[r_git_commit_objects]]
==== Αντικείμενα υποβολής

Αν έχουμε κάνει όλα τα παραπάνω, τώρα θα πρέπει να έχουμε τρία δέντρα που δείχνουν τα διαφορετικά στιγμιότυπα του έργου μας που θέλουμε να παρακολουθήσουμε, αλλά το προηγούμενο πρόβλημα παραμένει: πρέπει να θυμόμαστε και τις τρεις τιμές SHA-1 για να ανακαλέσουμε τα στιγμιότυπα.
Επίσης, δεν έχουμε πληροφορίες σχετικά με το ποιος αποθήκευσε τα στιγμιότυπα, πότε αποθηκεύτηκαν ή γιατί αποθηκεύτηκαν.
Αυτή είναι η βασική πληροφορία που αποθηκεύει το αντικείμενο υποβολής για μας.

Για να δημιουργήσουμε ένα αντικείμενο υποβολής, καλούμε την `commit-tree` και καθορίζουμε το SHA-1 ενός μόνο δέντρου και ποια αντικείμενα υποβολής, αν υπάρχουν, που προηγούνταν ακριβώς πριν από αυτό.
Ξεκινάμε με το πρώτο δέντρο που γράψαμε:

[source,console]
----
$ echo 'first commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d
----

[NOTE]
====
Θα λάβουμε διαφορετική τιμή κρυπτογράφησης (hash value) λόγω διαφορετικής ώρας δημιουργίας και δεδομένα συγγραφέα.
Επιπλέον, ενώ αρχιτεκτονικά κάθε υποβολή μπορεί να αναπαραχθεί επακριβώς δίνοντας αυτά τα δεδομένα, προήγουμενες λεπτομέριες της δομής αυτού του βιβλίου, δήλωναν ότι οι εκτυπωμένες κρυπτογράφησεις υποβολών μπορεί να μην αντιστοιχούν σε δεδομένες υποβολές.
Αντικαθιστούμε κρυπτογράφησεις υποβολών και ετικετών (tags) με τα δικά μας αθροίσματα ελέγχου (checksums) πιο μετά σε αυτό το κεφάλαιο.
====

Τώρα μπορούμε να δούμε το νέο μας αντικείμενο υποβολής με την `cat-file`:

[source,console]
----
$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon <schacon@gmail.com> 1243040974 -0700
committer Scott Chacon <schacon@gmail.com> 1243040974 -0700

first commit
----

Η μορφή ενός αντικειμένου υποβολής είναι απλή: καθορίζει το δέντρο ανώτερου επιπέδου  για το στιγμιότυπο του έργου σε εκείνο το σημείο· οι υποβολές του γονέα αν υπάρχουν (το αντικείμενο υποβολής που περιγράφηκε παραπάνω δεν έχει κανένα γονεά)· τις πληροφορίες συγγραφέα/υποβάλλοντος (οι οποίες χρησιμοποιούν τις ρυθμίσεις διαμόρφωσης `user.name` και `user.email` και μία χρονοσήμανση)· μια κενή γραμμή και στη συνέχεια το μήνυμα υποβολής.

Στη συνέχεια, θα γράψουμε τα άλλα δύο αντικείμενα υποβολής, καθένα από τα οποία αναφέρεται στην ακριβώς προηγούμενή του υποβολή:

[source,console]
----
$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9
----

Καθένα από τα τρία αντικείμενα υποβολής δείχνει σε ένα από τα τρία δέντρα στιγμιοτύπων που δημιουργήσαμε.
Περιέργως, έχουμε πλέον ένα πραγματικό ιστορικό Git, το οποίο μπορούμε να δούμε με την εντολή `git log`, αν την εκτελέσουμε στον SHA-1 της τελευταίας υποβολής:

[source,console]
----
$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:15:24 2009 -0700

	third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:14:29 2009 -0700

	second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)
----

Καταπληκτικό.
Έχουμε χρησιμοποιήσει λειτουργίες χαμηλού επιπέδου για να δημιουργήσουμε ένα ιστορικό Git χωρίς να χρησιμοποιήσουμε καμία από τις εντολές του υψηλού επιπέδου.
Αυτό είναι ουσιαστικά που κάνει το Git όταν τρέχουμε τις εντολές `git add` και `git commit` —αποθηκεύει blobs για τα αλλαγμένα αρχεία που έχουν αλλάξει, ενημερώνει το ευρετήριο, γράφει δέντρα, και γράφει αντικείμενα υποβολής που αναφέρονται στα δέντρα του ανώτερου επιπέδου και τις προηγούμενες υποβολές.
Αυτά τα τρία κύρια αντικείμενα Git —το blob, το δέντρο και η υποβολή— αποθηκεύονται αρχικά ως ξεχωριστά αρχεία στον κατάλογο `.git/objects`.
Εδώ είναι όλα τα αντικείμενα στον κατάλογο τώρα, σχολιασμένα με αυτό που αποθηκεύουν:

[source,console]
----
$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1
----

Αν ακολουθήσουμε όλους τους εσωτερικούς δείκτες, παίρνουμε ένα γράφημα αντικειμένων περίπου σαν αυτό:

.Όλα τα αντικείμενα στον κατάλογό μας Git.
image::images/data-model-3.png[Όλα τα αντικείμενα στον κατάλογό μας Git]

==== Αποθήκευση αντικειμένων

Αναφέραμε προηγουμένως ότι υπάρχει μια κεφαλίδα που αποθηκεύται με κάθε αντικείμενο που υποβάλουμε την βάση δεδομένων αντικειμένων του Git μας.
Ας σταθούμε ένα λεπτό για να δούμε πώς το Git αποθηκεύει τα αντικείμενά του.
Θα δούμε πώς μπορούμε να αποθηκεύσουμε ένα αντικείμενο blob —στην περίπτωση αυτή, τη συμβολοσειρά "`what is up, doc?`" — διαδραστικά στη γλώσσα Ruby.

Μπορούμε να ξεκινήσουμε μία διαδραστική λειτουργία Ruby με την εντολή `irb`:

[source,console]
----
$ irb
>> content = "what is up, doc?"
=> "what is up, doc?"
----

Το Git πρώτα κατασκευάζει μια κεφαλίδα που ξεκινάει με τον τύπο του αντικειμένου, στην περίπτωση αυτή ένα blob.
Σε αυτό το πρώτο μερός, το Git προσθέτει ένα κενό που ακολουθείται από το μέγεθος του περιεχομένου σε bytes, και τέλος ένα null byte:

[source,console]
----
>> header = "blob #{content.bytesize}\0"
=> "blob 16\u0000"
----

Το Git ενώνει την κεφαλίδα και το αρχικό περιεχόμενο και στη συνέχεια υπολογίζει το άθροισμα ελέγχου SHA-1 αυτού του νέου περιεχομένου.
Μπορούμε να υπολογίσουμε την τιμή SHA-1 μιας συμβολοσειράς στη Ruby, αν συμπεριλάβουμε τη βιβλιοθήκη SHA1 digest, με την εντολή `require` και στη συνέχεια να καλέσουμε `Digest::SHA1.hexdigest()` με τη συμβολοσειρά:

[source,console]
----
>> store = header + content
=> "blob 16\u0000what is up, doc?"
>> require 'digest/sha1'
=> true
>> sha1 = Digest::SHA1.hexdigest(store)
=> "bd9dbf5aae1a3862dd1526723246b20206e5fc37"
----

Ας συγκρίνουμε αυτό, με την έξοδο της εντολής `git hash-object`.
Εδω χρησιμοποιούμε `echo -n` για να αποτρέψουμε την προσθήκη νέας γραμμής στην εισαγωγή.

[source,console]
----
$ echo -n "what is up, doc?" | git hash-object --stdin
bd9dbf5aae1a3862dd1526723246b20206e5fc37
----

Το Git συμπιέζει το νέο περιεχόμενο με το zlib, κάτι που μπορούμε να κάνουμε στη Ruby με τη βιβλιοθήκη zlib.
Πρώτα, πρέπει να απαιτήσουμε τη βιβλιοθήκη και στη συνέχεια να εκτελέσουμε την `Zlib::Deflate.deflate()` στο περιεχόμενο:

[source,console]
----
>> require 'zlib'
=> true
>> zlib_content = Zlib::Deflate.deflate(store)
=> "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"
----

Τέλος, θα γράψουμε το περιεχόμενό μας που έχει συμπιεστεί με το zlib σε ένα αντικείμενο στον δίσκο.
Θα καθορίσουμε τη διαδρομή (path) του αντικειμένου που θέλουμε να γράψουμε (οι δύο πρώτοι χαρακτήρες της τιμής SHA-1 είναι το όνομα του υποκαταλόγου και οι τελευταίοι 38 χαρακτήρες είναι το όνομα του αρχείου μέσα σε αυτόν τον κατάλογο).
Στη Ruby, μπορούμε να χρησιμοποιήσουμε τη συνάρτηση `FileUtils.mkdir_p()` για να δημιουργήσουμε τον υποκατάλογο εάν δεν υπάρχει.
Στη συνέχεια ανοίγουμε το αρχείο με τη `File.open()` και γράφουμε το προηγουμένως συμπιεσμένο από το zlib περιεχόμενο στο αρχείο με κλήση της `write()` στον προκύπτων αρχείο:

[source,console]
----
>> path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=> ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
>> require 'fileutils'
=> true
>> FileUtils.mkdir_p(File.dirname(path))
=> ".git/objects/bd"
>> File.open(path, 'w') { |f| f.write zlib_content }
=> 32
----

Ας ελέγξουμε το περιεχόμενο του αντικειμένου χρησιμοποιώντας `git cat-file`:

[source,console]
---
$ git cat-file -p bd9dbf5aae1a3862dd1526723246b20206e5fc37
what is up, doc?
---

Αυτό ήταν· έχουμε δημιουργήσει ένα έγκυρο αντικείμενο blob του Git.

Όλα τα αντικείμενα Git αποθηκεύονται με τον ίδιο τρόπο, αλλά με διαφορετικούς τύπους —αντί για τη συμβολοσειρά του blob, η κεφαλίδα θα αρχίσει με την υποβολή ή το δέντρο.
Επίσης, παρόλο που το περιεχόμενο των blob μπορεί να είναι σχεδόν ο,τιδήποτε, τα περιεχόμενα της υποβολής και του δέντρου είναι μορφοποιημένα με πολύ συγκεκριμένο τρόπο.
