=== Βασικές έννοιες διακλαδώσεων και συγχωνεύσεων

Ας δούμε ένα απλό παράδειγμα διακλάδωσης και συγχώνευσης με μία ροή εργασίας που είναι πιθανό να χρησιμοποιήσουμε στον πραγματικό κόσμο.
Θα ακολουθήσουμε τα παρακάτω βήματα:

. Θα κάνουμε αλλαγές σε μία ιστοσελίδα.
. Θα δημιουργήσουμε έναν κλάδο για μία νέα ιστορία χρήστη (user story) την οποία δουλεύουμε.
. θα κάνουμε αλλαγές σε αυτό τον κλάδο.

Σε αυτό το σημείο θα δεχτούμε ένα τηλεφώνημα ότι υπάρχει ένα άλλο κρίσιμο πρόβλημα και πρέπει να αναπτύξουμε μία άμεση λύση.
Θα κάνουμε τα παρακάτω:

. Θα μεταβούμε στον κλάδο παραγωγής.
. Θα δημιουργήσουμε έναν κλάδο στον οποίο θα προσθέσουμε την επείγουσα λυση (hotfix).
. Αφού ο κώδικάς μας δοκιμαστεί, θα συγχωνεύσουμε τον κλάδο με το hotfix και θα τον ωθήσουμε στην παραγωγή.
. Θα επιστρέψουμε στην αρχική ιστορία χρήστη και θα συνεχίσουμε να την δουλεύουμε.

[[r_basic_branching]]
==== Διακλαδώσεις -- τα βασικά

(((κλάδοι, βασική ροή εργασίας)))
Αρχικά ας υποθέσουμε ότι δουλεύουμε σε ένα έργο και έχουμε κάνει ήδη μερικές υποβολές στον κλάδο `master`.

.Ένα απλό ιστορικό υποβολών
image::images/basic-branching-1.png[Ένα απλό ιστορικό υποβολών]

Αποφασίζουμε ότι θα δουλέψουμε στο πρόβλημα #53 του συστήματος παρακολούθησης προβλημάτων που χρησιμοποιεί η εταιρεία μας.
Για να δημιουργήσουμε έναν κλάδο και να μεταβούμε σε αυτό συγχρόνως, μπορούμε να τρέξουμε την εντολή `git checkout` με τη σημαία `-b`:

[source,console]
----
$ git checkout -b iss53
Switched to a new branch "iss53"
----

Η παραπάνω εντολή είναι συντομογραφία για το εξής:

[source,console]
----
$ git branch iss53
$ git checkout iss53
----

.Δημιουργία νέου δείκτη σε κλάδο
image::images/basic-branching-2.png[Δημιουργία νέου δείκτη σε κλάδο]

Επεξεργαζόμαστε την ιστοσελίδα μας και κάνουμε μερικές υποβολές.
Με τις υποβολές ο κλάδος `iss53` προχωρά, διότι τον έχουμε κάνει checkout (δηλαδή ο `HEAD` δείχνει σε αυτό τον κλάδο):

[source,console]
----
$ vim index.html
$ git commit -a -m 'Create new footer [issue 53]'
----

.Ο κλάδος `iss53` προχώρησε εξαιτίας των αλλαγών μας.
image::images/basic-branching-3.png[Ο κλάδος `iss53` προχώρησε εξαιτίας των αλλαγών μας.]

Τώρα λαμβάνουμε το τηλεφώνημα ότι υπάρχει ένα άλλο επείγον πρόβλημα στην ιστοσελίδα και πρέπει να το αντιμετωπίσουμε αμέσως. 
Στο Git, δεν είναι απαραίτητο να δουλέψουμε σε αυτό το πρόβλημα παράλληλα με τις αλλαγές που έχουμε ήδη κάνει στον κλάδο `iss53`, ούτε να καταβάλλουμε πολλή δουλειά ώστε να αναιρέσουμε τις αλλαγές που έχουμε ήδη κάνει και να δουλέψουμε στο επείγον πρόβλημα και να εφαρμόσουμε τη λύση μας σε ό,τι βρίσκεται εκείνη τη στιγμή στη γραμμή της παραγωγής. 
Το μόνο που έχουμε να κάνουμε είναι να επιστρέψουμε στον κλάδο `master`.

Ωστόσο πριν το κάνουμε αυτό, σημειώστε ότι αν υπάρχουν στον κατάλογο εργασίας μας ή στον προθάλαμο αλλάγες που δεν έχουν υποβληθεί και έρχονται σε σύγκρουση με τον κλάδο στον οποίο θέλουμε να μεταβούμε, το Git δεν θα μας αφήσει να αλλάξουμε κλάδο.
Το καλύτερο είναι να έχουμε μία καθαρή κατασταση εργασίας όταν μεταβαίνουμε από έναν κλάδο σε άλλο.
Υπάρχουν τρόποι να παρακάμψουμε αυτή τη συμπεριφορά (με τις εντολές `git stash` και `git commit --amend`) που θα καλύψουμε στη συνέχεια, στην ενότητα <<ch07-git-tools#r_git_stashing>>.
Προς το παρόν, ας υποθέσουμε ότι έχουμε υποβάλλει όλες τις αλλαγές μας, ώστε να μπορέσουμε να επιστρέψουμε στον κλάδο `master`:

[source,console]
----
$ git checkout master
Switched to branch 'master'
----

Σε αυτό το σημείο, ο κατάλογος εργασίας του έργου μας βρίσκεται ακριβώς στην κατάσταση στην οποία βρισκόταν πριν ξεκινήσουμε να δουλεύουμε για το πρόβλημα #53 και μπορούμε να συγκεντρωθούμε στο hotfix.
Αυτό είναι ένα σημαντικό σημείο που αξίζει να θυμόμαστε: όταν μεταβαίνουμε από έναν κλάδο σε έναν άλλο, το Git επαναφέρει τον κατάλογο εργασίας στην κατάσταση που είχε την τελευταία φορά που είχαμε κάνει κάποια υποβολή (commit) σε αυτό τον κλάδο. 
Προσθέτει, διαγράφει και τροποποιεί αρχεία αυτόματα ώστε να βεβαιωθεί ότι το αντίγραφο εργασίας μας είναι ίδιο με την κατάσταση του κλάδου αμέσως μετά την τελευταία υποβολή σε αυτό τον κλάδο.

Στη συνέχεια, πρέπει να δουλέψουμε για το hotfix. 
Ας φτιάξουμε έναν κλάδο `hotfix` στον οποίο θα εργαστούμε:

[source,console]
----
$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'Fix broken email address'
[hotfix 1fb7853] Fix broken email address
 1 file changed, 2 insertions(+)
----

.Κλάδος hotfix που βασίζεται στον κλάδο `master`
image::images/basic-branching-4.png[Κλάδος `hotfix` που βασίζεται στον κλάδο `master`]

Τώρα μπορούμε να κάνουμε τα τεστ μας, να βεβαιωθούμε ότι ο κώδικάς μας κάνει αυτό που θέλουμε, να τον συγχωνεύσουμε με τον κλάδο `master` και να τον προωθήσουμε στην παραγωγή.
Το τελευταίο το κάνουμε με την εντολή `git merge`:(((εντολές git, merge)))

[source,console]
----
$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
----

Σε αυτή τη συγχώνευση υπάρχει η έκφραση "`fast-forward`".
Επειδή η υποβολή `C4` στον οποίο έδειχνε ο κλάδος `hotfix` τον οποίο συγχωνεύσαμε ήταν ακριβώς μπροστά από την υποβολή `C2` στην οποία είμαστε, το Git απλά μετακίνησε τον δείκτη προς τα εμπρός. 
Με άλλα λόγια όταν προσπαθούμε να συγχωνεύσουμε μία υποβολή με μία άλλη υποβολή στην οποία μπορούμε να φτάσουμε ακολουθώντας το ιστορικό της πρώτης, το Git απλοποιεί τη διαδικασία μετακινώντας τον δείκτη σε εκείνο το σημείο, διότι δεν υπάρχει άλλη αποκλίνουσα εργασία που θα πρέπει να συγχωνευτεί -- αυτό ονομάζεται "`ταχυπροώθηση`" ("`fast-forward`").

Η αλλαγή μας τώρα υπάρχει στο στιγμιότυπο της υποβολής στην οποία δείχνει ο κλάδος `master` και μπορούμε να δημοσιεύσουμε τη διόρθωσή μας.

.Ο κλάδος `master` ταχυπροωθήθηκε στον κλάδο `hotfix`.
image::images/basic-branching-5.png[Ο κλάδος `master` ταχυπροωθήθηκε στον κλάδο `hotfix`.]

Αφού ο σημαντικότατος διορθωτικός μας κώδικας έχει δημοσιευτεί, είμαστε έτοιμοι να επανέλθουμε στην εργασία την οποία κάναμε πριν μας διακόψει το τηλεφώνημα.
Προτού όμως συνεχίσουμε, θα διαγράψουμε τον κλάδο `hotfix`, διότι δεν τον χρειαζόμαστε πλέον -- ο κλάδος `master` δείχνει ακριβώς στην ίδια θέση.
Μπορούμε να τον διαγράψουμε με την επιλογή `-d` στην εντολή `git branch`:

[source,console]
----
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).
----

Τώρα μπορούμε να επιστρέψουμε στον κλάδο εργασίας του προβλήματος #53 και να συνεχίσουμε να δουλεύουμε σ' αυτό.

[source,console]
----
$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'Finish the new footer [issue 53]'
[iss53 ad82d7a] Finish the new footer [issue 53]
1 file changed, 1 insertion(+)
----

.Η εργασία συνεχίζει στον κλάδο `iss53`
image::images/basic-branching-6.png[Η εργασία συνεχίζει στον κλάδο `iss53`]

Σε αυτό το σημείο αξίζει να σημειωθεί ότι οι αλλαγές που κάναμε στον κλάδο `hotfix` δεν περιέχονται στα αρχεία του κλάδου `iss53`.
Αν θέλουμε να τα ενσωματώσουμε, μπορούμε να συγχωνεύσουμε τον κλάδο `master` στον κλάδο `iss53` τρέχοντας την εντολή `git merge master` ή μπορούμε να αναβάλουμε την ενσωμάτωση αυτών των αλλαγών μέχρι να αποφασίσουμε να ξαναβάλουμε τον κλάδο `iss53` μέσα στον κλάδο `master` αργότερα.

[[r_basic_merging]]
==== Συγχωνεύσεις -- τα βασικά

(((κλάδοι, συγχώνευση)))(((συγχώνευση)))(((branches, merging)))(((merging)))
Ας υποθέσουμε τώρα ότι έχουμε αποφασίσει ότι η εργασία μας για το πρόβλημα #53 έχει ολοκληρωθεί και είναι έτοιμη να συγχωνευτεί στον κλάδο `master`.
Για να το κάνουμε αυτό, αρκεί να συγχωνεύσουμε τον κλάδο `iss53` στον κλάδο `master`, λίγο-πολύ με τον ίδιο τρόπο που συγχωνεύσαμε τον κλάδο `hotfix` προηγουμένως.
Το μόνο που έχουμε να κάνουμε είναι να μεταβούμε στον κλάδο στον οποίο θέλουμε να ενσωματώσουμε τον άλλο κλάδο και να τρέξουμε την εντολή `git merge`:

[source,console]
----
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
----

Το μήνυμα στην οθόνη διαφέρει λίγο από εκείνο που πήραμε όταν συγχωνεύσαμε τον κλάδο `hotfix` προηγουμένως.
Σε αυτή την περίπτωση, το ιστορικό των αλλαγών απέκλινε σε κάποιο παλιότερο σημείο.
Επειδή η υποβολή στον κλάδο στον οποίο βρίσκεστε δεν είναι άμεσος πρόγονος του κλάδου τον οποίο ενσωματώνουμε, το Git πρέπει να κάνει λίγη δουλίτσα.
Σε αυτή την περίπτωση, το Git κάνει μία απλή _τριμερή_ συγχώνευση, χρησιμοποιώντας τα στιγμιότυπα στο τέλος του κάθε κλάδου και τον κοινό πρόγονο των δύο.

.Τρία στιγμιότυπα που χρησιμοποιούνται σε μία τυπική συγχώνευση
image::images/basic-merging-1.png[Τρία στιγμιότυπα που χρησιμοποιούνται σε μία τυπική συγχώνευση]

Αντί, λοιπόν, το Git να μετακινήσει τον δείκτη του κλάδου προς τα εμπρός, δημιουργεί ένα νέο στιγμιότυπο που προκύπτει από αυτή την τριμερή συγχώνευση και αυτομάτως δημιουργεί μία νέα υποβολή που δείχνει σε αυτό το στιγμιότυπο.
Αυτό ονομάζεται _υποβολή συγχώνευσης_ (merge commit) και έχει την ιδιαιτερότητα ότι έχει περισσότερους από έναν γονείς.

.Μία υποβολή συγχώνευσης
image::images/basic-merging-2.png[Μία υποβολή συγχώνευσης]

Τώρα που η εργασία μας έχει συγχωνευτεί, δεν χρειαζόμαστε πλέον τον κλάδο `iss53`.
Μπορούμε να κλείσουμε το ζήτημα στο σύστημα παρακολούθησης προβλημάτων μας και να διαγράψουμε τον κλάδο:

[source,console]
----
$ git branch -d iss53
----

[[r_basic_merge_conflicts]]
==== Συγκρούσεις συγχωνεύσεων -- τα βασικά

(((συγχώνευση, συγκρούσεις)))(((merging, conflicts)))
Ενίοτε, η διαδικασία συγχώνευσης δεν εξελίσσεται τόσο ομαλά.
Αν έχουμε τροποποιήσει το ίδιο σημείο του ίδιου αρχείου με διαφορετικό τρόπο στους δύο κλάδους που συγχωνεύουμε, το Git δεν θα μπορέσει να τους συγχωνεύσει παστρικά.
Αν η λύση μας για το πρόβλημα #53 και η λύση μας για το επείγον πρόβλημα τροποποίησαν το ίδιο τμήμα ενός αρχείου, θα πάρουμε ένα μήνυμα _σύγκρουσης συγχώνευσης_ περίπου σαν το παρακάτω:

[source,console]
----
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
----

Το Git δεν μπόρεσε να δημιουργήσει αυτόματα μία νέα υποβολή συγχώνευσης.
Διέκοψε τη διαδικασία, ώστε να επιλύσουμε τη σύγκρουση.
Αν θέλουμε να δούμε ποια αρχεία δεν έχουν συγχωνευτεί σε οποιοδήπτε σημείο μετά από μία σύγκρουση συγχώνευσης, τρέχουμε την εντολή `git status`:

[source,console]
----
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")
----

Οτιδήποτε εμπλέκεται σε σύγκρουση συγχώνευσης και δεν έχει επιλυθεί καταγράφεται ως unmerged.
Το Git προσθέτει τυποποιημένους σημειωτές "`επίλυσης σύγκρουσης`" στα αρχεία που εμπλέκονται σε συγκρούσεις, ώστε να τα ανοίξουμε και να επιλύσουμε αυτές τις διαφορές. 
Το αρχείο μας θα περιέχει ένα τμήμα που θα φαίνεται κάπως έτσι:

[source,html]
----
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
----

Αυτό σημαίνει πως η έκδοση στο `HEAD` (δηλαδή το `master` κλάδο, γιατί σε αυτόν ήμασταν όταν τρέξαμε στην εντολή συγχώνευσης) είναι το πάνω μέρος του μπλόκ (οτιδήποτε πάνω από `=======`), ενώ η έκδοση του κλάδου `iss53` είναι ότι φαίνεται στο κάτω μέρος του μπλόκ.
Προκειμένου να επιλύσουμε τη σύγκρουση, πρέπει είτε να επιλέξουμε τη μία ή την άλλη έκδοση είτε να συγχωνεύσουμε τα περιεχόμενα οι ίδιοι.
Για παράδειγμα, μπορεί να θέλουμε να επιλύσουμε αυτή τη σύγκρουση αντικαθιστώντας ολόκληρο το τμήμα με το παρακάτω:

[source,html]
----
<div id="footer">
please contact us at email.support@github.com
</div>
----

Αυτή η επίλυση της σύγκρουσης περιέχει λίγο από κάθε τμήμα και οι γραμμές που περιέχουν τα `<<<<<<<`, `=======` και `>>>>>>>` έχουν αφαιρεθεί εντελώς.
Αφού έχουμε επιλύσει όλα τα τμήματα σε κάθε αρχείο που εμπλέκεται σε σύγκρουση, τρέχουμε `git add` σε καθένα από αυτά τα αρχεία, ώστε να επισημανθεί ως επιλυμένο.
Αν το αρχείο περάσει στο στάδιο καταχώρησης, αυτό σημαίνει ότι έχει επιλυθεί.

Αν θέλουμε να χρησιμοποιήσουμε κάποιο γραφικό εργαλείο για να επιλύσουμε αυτές τις συγκρούσεις, τρέχουμε `git mergetool` για να εκκινήσουμε ένα κατάλληλο γραφικό εργαλείο συγχώνευσης που μας καθοδηγεί κατά την επίλυση των συγκρούσεων:(((εντολές git, mergetool)))

[source,console]
----
$ git mergetool

This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):
----

Αν θέλουμε να χρησιμοποιήσουμε κάποιο εργαλείο συγχώνευσης διαφορετικό από το προεπιλεγμένο (το Git επέλεξε το `opendiff` σε αυτή την περίπτωση, διότι εκτελέσαμε την εντολή σε Mac), μπορούμε να δούμε όλα τα εργαλεία που υποστηρίζονται στο πάνω μέρος μετά από το "`one of the following tools.`"
Απλά γράφουμε το όνομα του εργαλείου που προτιμάμε.

[NOTE]
====
Αν χρειάζεστε πιο προχωρημένα εργαλεία για να επιλύσετε περίπλοκες συγκρούσεις συγχωνεύσεων, θα μιλήσουμε σχετικά στην ενότητα <<ch07-git-tools#r_advanced_merging>>.
====

Αφού βγούμε από το εργαλείο συγχώνευσης, το Git μας ρωτάει αν η συγχώνευση ήταν επιτυχής.
Αν του πούμε ότι ήταν, ωθεί το αρχείο στον προθάλαμο ώστε να επισημανθεί ως επιλυμένο.
Μπορούμε να τρέξουμε την εντολή `git status` ξανά για να επιβεβαιωθούμε ότι όλες οι συγκρούσεις έχουν επιλυθεί:

[source,console]
----
$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html
----

Αν είμαστε ευχαριστημένοι με το αποτέλεσμα και επιβεβαιωθούμε ότι όλα τα αρχεία που εμπλέκονται σε συγκρούσεις έχουν τοποθετηθεί στο στάδιο καταχώρησης, μπορούμε να πληκτρολογήσουμε `git commit` για να οριστικοποιήσουμε την υποβολή συγχώνευσης.
Το μήνυμα υποβολής είναι εξ ορισμού κάπως έτσι:

[source,console]
----
Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#	.git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#	modified:   index.html
#
----

Εφόσον θεωρούμε ότι θα είναι χρήσιμο σε όσους δουν αυτή τη συγχώνευση στο μέλλον, μπορούμε να τροποποιήσουμε αυτό το μήνυμα με λεπτομέρειες σχετικά με το πώς επιλύσαμε τη συγχώνευση και να εξηγήσουμε γιατί κάναμε ό,τι κάναμε, εφόσον δεν είναι προφανές.
