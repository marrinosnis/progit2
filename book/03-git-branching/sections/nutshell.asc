[[r_git_branches_overview]]
=== Οι κλάδοι με λίγα λόγια

Για να κατανοήσετε πραγματικά τον τρόπο με τον οποίο το Git υλοποιεί τις διακλαδώσεις, πρέπει πρώτα να εξετάσετε τον τρόπο με τον οποίο το Git αποθηκεύει τα δεδομένα.

Όπως ίσως θυμάστε από την ενότητα <<ch01-introduction#ch01-introduction>>, το Git δεν αποθηκεύει τα δεδομένα ως μία ακολουθία αλλαγών ή διαφορών αλλά ως μία ακολουθία _στιγμιότυπων_ (snapshots).

Όταν κάνετε μία υποβολή (commit), το Git αποθηκεύει ένα αντικείμενο υποβολής που περιέχει έναν δείκτη προς το στιγμιότυπο του περιεχομένου που έχει υποβληθεί.
Αυτό το αντικείμενο περιέχει επίσης το όνομα και e-mail του συγγραφέα, το μήνυμα που έχετε πληκτρολογήσει καθώς και δείκτες προς την υποβολή ή τις υποβολές που προηγήθηκαν ακριβώς πριν από αυτή την υποβολή (δηλαδή, τον γονέα ή τους γονείς της): όταν ένα αρχείο υποβάλλεται για πρώτη φορά, τότε δεν έχει κανέναν γονέα· μία συνηθισμένη υποβολή έχει έναν γονέα, ενώ μία υποβολή που προέκυψε από τη συγχώνευση δύο ή περισσότερων κλάδων έχει περισσότερους από έναν γονέα.

Για να το οπτικοποιήσουμε λίγο, ας υποθέσουμε ότι έχετε έναν κατάλογο που περιέχει τρία αρχεία, τα οποία έχετε προσθέσει στον προθάλαμο και στη συνέχεια υποβάλετε (commit).
Κατά την προσθήκη των αρχείων στον προθάλαμο υπολογίζονται τα αθροίσματα ελέγχου (checksums) των αρχείων (με τον αλγόριθμο SHA-1, που αναφέρθηκε στην ενότητα <<ch01-introduction#ch01-introduction>>), αποθηκεύονται οι συγκεκριμένες εκδόσεις των αρχείων στο αποθετήριο Git (το Git ονομάζει αυτές τις εκδόσεις _blobs_) και προσθέτει τα αθροίσματα ελέγχου στην ενδιαμέση περιοχή.

[source,console]
----
$ git add README test.rb LICENSE
$ git commit -m 'Initial commit'
----

Όταν κάνετε την υποβολή, τρέχοντας την εντολή `git commit`, το Git υπολογίζει ένα άθροισμα ελέγχου για καθέναν υποκατάλογο (στη συγκεκριμένη περίπτωση μόνο για τον βασικό κατάλογο του έργου) και τους αποθηκεύει ως αντικείμενα δομής δένδρου στο αποθετήριο Git.
Στη συνέχεια το Git δημιουργεί ένα αντικείμενο υποβολής που περιέχει τα μεταδεδομένα και έναν δείκτη στη βάση του δένδρου του έργου, ώστε να μπορεί να επαναδημιουργήσει το στιγμιότυπο, όταν χρειαστεί.(((εντολές git, commit)))

Πλέον το αποθετήριό σας περιέχει πέντε αντικείμενα: τρία blob για τα περιεχόμενα των αρχείων (ένα blob για κάθε αρχείο), μία δομή δένδρου που καταγράφει τα περιεχόμενα του καταλόγου και προσδιορίζει ποιο αρχείο αντιστοιχίζεται σε ποιο blob και ένα αντικείμενο commit που περιέχει τον δείκτη στον βασικό κατάλογο και όλα τα μεταδεδομένα της υποβολής.

.Μια υποβολή και το δένδρο της.
image::images/commit-and-tree.png[Μια υποβολή και το δένδρο της.]

Αν κάνετε μερικές αλλαγές και τις υποβάλετε, η επόμενη υποβολή αποθηκεύει έναν δείκτη στην ακριβώς προηγούμενη υποβολή.

.Υποβολές (commits) και οι γονείς τους.
image::images/commits-and-parents.png[Υποβολές (commits) και οι γονείς τους.]

Οι κλάδοι του Git είναι απλά μετακινήσιμοι δείκτες σε υποβολές. 
Το προεπιλεγμένο όνομα κλάδου στο Git είναι `master` (κύριος κλάδος).
Όταν ξεκινάτε να κάνετε υποβολές, σας δίνεται ένας κλάδος `master` που δείχνει στην τελευταία υποβολή που κάνατε. 
Κάθε φορά που υποβάλλετε, ο κλάδος `master` προχωρά αυτόματα.

[NOTE]
====
Ο κλάδος `master` στο Git δεν είναι κάποιος ειδικός κλάδος.(((master)))
Είναι ακριβώς το ίδιο με οποιονδήποτε άλλο κλάδο. 
Ο μόνος λόγος για τον οποίο σχεδόν κάθε αποθετήριο έχει έναν κλάδο `master` είναι επειδή η εντολή `git init` τον ονομάζει έτσι και οι περισσότεροι χρήστες του Git δεν ασχολούνται με το να τον αλλάξουν. 
====

.Ένας κλάδος και το ιστορικό υποβολών του.
image::images/branch-and-history.png[Ένας κλάδος και το ιστορικό υποβολών του.]


[[r_create_new_branch]]
==== Δημιουργία νέου κλάδου

(((κλάδοι, δημιουργία)))
Τι γίνεται όταν δημιουργείτε έναν νέο κλάδο; 
Αυτό που συμβαίνει είναι ότι δημιουργείται ένα νέος δείκτης τον οποίο μπορείτε να μετακινείτε από δω κι από κει.
Ας πείτε ότι δημιουργείτε έναν νέο κλάδο που ονομάζεται `testing`.
Αυτό γίνεται με την εντολή `git branch`:(((εντολές git, branch)))

[source,console]
----
$ git branch testing
----

Αυτή η εντολή δημιουργεί έναν νέο δείκτη στην υποβολή στην οποία βρίσκεστε αυτή τη στιγμή. 

.Δύο κλάδοι που δείχνουν στην ίδια ακολουθία υποβολών.
image::images/two-branches.png[Δύο κλάδοι που δείχνουν στην ίδια ακολουθία υποβολών.]

Πώς όμως γνωρίζει το Git σε ποιον κλάδο βρίσκεστε τώρα;
Το γνωρίζει επειδή διατηρεί έναν ειδικό δείκτη που ονομάζεται `HEAD`.
Σημειώστε ότι αυτός ο δείκτης `HEAD` είναι πολύ διαφορετικός από την έννοια του `HEAD` με την οποία είστε ενδεχομένως εξοικειωμένοι σε άλλα VCS, όπως το Subversion ή το CVS.
Στο Git αυτός είναι ένας δείκτης στον τοπικό κλάδο στον οποίο στον οποίο βρίσκεστε αυτή τη στιγμή. 
Στη συγκεκριμένη περίπτωση, βρίσκεστε ακόμα στον κλάδο `master`.
Η εντολή `git branch` απλά _δημιούργησε_ έναν νέο κλάδο -- δεν μετέβη σε αυτό τον κλάδο.

.Ο δείκτης HEAD δείχνει σε έναν κλάδο.
image::images/head-to-master.png[Ο δείκτης HEAD δείχνει σε έναν κλάδο.]

Αυτό μπορείτε να το διαπιστώσετε εύκολα τρέχοντας την εντολή `git log` με την επιλογή `--decorate`, που παραθέτει πού δείχνουν οι δείκτες των κλάδων. 

[source,console]
----
$ git log --oneline --decorate
f30ab (HEAD -> master, testing) Add feature #32 - ability to add new formats to the central interface
34ac2 Fix bug #1328 - stack overflow under certain conditions
98ca9 Initial commit
----

Βλέπετε τους κλάδους `master` και `testing` που βρίσκονται δίπλα στην υποβολή `f30ab`.


[[r_switching_branches]]
==== Μετάβαση σε άλλο κλάδο

(((κλάδοι, μετάβαση)))
Για να μεταβείτε σε έναν ήδη υπάρχοντα κλάδο, τρέχετε την εντολή `git checkout`.(((εντολές git, checkout)))
Ας μεταβείτε στον νέο κλάδο `testing`:

[source,console]
----
$ git checkout testing
----

Η εντολή αυτή μετατοπίζει τον δείκτη `HEAD` ώστε να δείχνει στον κλάδο `testing`.

.Ο `HEAD` δείχνει στον τρέχοντα κλάδο.
image::images/head-to-testing.png[Ο `HEAD` δείχνει στον τρέχοντα κλάδο.]

Ποια είναι η σημασία αυτού του πράγματος;
Ας κάνουμε ακόμα μία υποβολή:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'Make a change'
----

.Ο κλάδος `HEAD` μετακινείται ότι γίνεται μία υποβολή.
image::images/advance-testing.png[Ο κλάδος `HEAD` μετακινείται ότι γίνεται μία υποβολή.]

Αυτό είναι ενδιαφέρον, διότι τώρα ο νέος σας κλάδος `testing` έχει προχωρήσει, αλλά ο κλάδος `master` ακόμα δείχνει στην υποβολή που βρισκόσασταν όταν είχατε τρέξει την εντολή `git checkout` για να αλλάξετε κλάδο. 
Ας επιστρέψουμε στον κλάδο `master`:

[source,console]
----
$ git checkout master
----

[NOTE]
.Η εντολή `git log` δεν δείχνει _όλους_ τους κλάδους _πάντα_
====
Αν εκτελούσατε `git log` τώρα, θα αναρωτιόσασταν πού πήγε ο κλάδος `testing` που μόλις δημιουργήσατε, αφού δεν θα εμφανιζόταν στην έξοδο της εντολής.

Ο κλάδος δεν έχει εξαφανιστεί· το Git δεν γνωρίζει ότι ενδιαφέρεστε για αυτόν τον κλάδοκαι προσπαθεί να σας δείξει μόνο αυτό για το οποίο νομίζει ότι σας ενδιαφέρει.
Με άλλα λόγια, εξ ορισμού, η `git log` θα σας δείξει το ιστορικό υποβολών του κλάδου τον οποίο έχετε κάνει checked out.

Για να δείτε όλο το ιστορικό υποβολών για τον κλάδο που θέλετε, πρέπει να το πείτε ρητά: `git log testing`.
Για να δείτε το ιστορικό όλων των κλάδων, προσθέστε και το `--all` στην εντολή `git log`.
====

.Ο δείκτης `HEAD` μετακινείται όταν εκτελείτε `checkout`.
image::images/checkout-master.png[Ο δείκτης `HEAD` μετακινείται όταν εκτελείτε `checkout`.]

Αυτή η εντολή έκανε δύο πράγματα: 
Μετατόπισε τον δείκτη `HEAD` ώστε να ξαναδείχνει στον κλάδο `master` και επανέφερε τα αρχεία στον τρέχοντα κατάλογο στο στιγμιότυπο που δείχνει ο κλάδος `master'.
Αυτό σημαίνει επίσης ότι όποιες αλλαγές κάνετε από αυτό το σημείο και μετά θα αποκλίνουν από μια  παλιότερη έκδοση του έργου. 
Ουσιαστικά αναιρεί όποιες αλλαγές έχετε κάνει στον κλάδο `testing` ώστε να μπορέσετε να κινηθείτε σε μία διαφορετική κατεύθυνση.

[NOTE]
.Η μετάβαση από έναν κλάδο σε άλλον αλλάζει τα αρχεία στον κατάλογο εργασίας
===
Είναι σημαντικό να τονιστεί ότι όταν μετακινείστε από έναν κλάδο σε άλλο στο Git, τα αρχεία στον τρέχοντα κατάλογο αλλάζουν.
Αν μεταβείτε σε κάποιον παλιότερο κλάδο, ο τρέχων κατάλογος θα επαναφερθεί στην κατάσταση στην οποία βρισκόταν την τελευταία φορά που είχατε κάνει κάποια υποβολή σε αυτό τον κλάδο. 
Αν το Git δεν μπορεί να το κάνει χωρίς προβλήματα, δεν θα σας επιτρέψει να μεταβείτε σε αυτό τον κλάδο.
===

Ας κάνουμε μερικές ακόμα αλλαγές και να τις υποβάλλουμε:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'Make other changes'
----

Τώρα το ιστορικό του έργου έχει αποκλίνει (βλ. <<rdivergent_history>>).
Δημιουργήσατε έναν κλάδο, μεταβήκατε σε αυτόν, κάνατε κάποιες αλλαγές και μετά επιστρέψατε στον κύριο κλάδο σας και κάνατε κάποιες άλλες αλλαγές.
Οι αλλαγές αυτές είναι απομονωμένες σε διαφορετικούς κλάδους: μπορείτε να μεταπηδείτε από τον έναν κλάδο στον άλλο και να τους συγχωνεύσετε όταν είστε έτοιμοι. 
Και όλα αυτά τα καταφέρνετε με απλές εντολές `branch`, `checkout` και `commit`.

[[rdivergent_history]]
.Αποκλίνον ιστορικό.
image::images/advance-master.png[Αποκλίνον ιστορικό.]

Αυτό μπορείτε επίσης να το δείτε εύκολα με την εντολή `git log`.
Αν εκτελέσετε την εντολή `git log --oneline --decorate --graph --all` θα εκτυπωθεί το ιστορικό των υποβολών στο οποίο θα φαίνεται πού βρίσκονται οι δείκτες των κλάδων σας και με ποιον τρόπο έχει αποκλίνει το ιστορικό.

[source,console]
----
$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) Make other changes
| * 87ab2 (testing) Make a change
|/
* f30ab Add feature #32 - ability to add new formats to the central interface
* 34ac2 Fix bug #1328 - stack overflow under certain conditions
* 98ca9 Initial commit of my project
----

Επειδή ένας κλάδος στο Git είναι στην πραγματικότητα ένα αρχείο που περιέχει τους 40 χαρακτήρες του αθροίσματος ελέγχου SHA-1 της υποβολής στην οποία δείχνει, η δημιουργία και καταστροφή κλάδων είναι μία φθηνή διαδικασία.
Η δημιουργία ενός κλάδου είναι τόσο γρήγορη και απλή όσο το να γράφονται 41 byte σε ένα αρχείο (40 αλφαριθμητικοί χαρακτήρες και ένας χαρακτήρας αλλαγής γραμμής).

Αυτή είναι μία σημαντική διαφορά σε σχέση με τον τρόπο με τον οποίο τα περισσότερα παλιότερα VCS δημιουργούν κλάδους, που περιλαμβάνει την αντιγραφή όλων των αρχείων του έργου σε έναν άλλο κατάλογο. 
Αυτό μπορεί να διαρκέσει αρκετά δευτερόλεπτα ή ακόμα και λεπτά, ανάλογα με το μέγεθος του έργου, ενώ στο Git η διαδικασία είναι σχεδόν στιγμιαία. 
Επιπλέον, επειδή σε κάθε υποβολή καταγράφονται οι γονείς της, η εύρεση μίας κατάλληλης βάσης για συγχώνευση γίνεται αυτόματα και γενικά πολύ εύκολα.
Αυτά τα χαρακτηριστικά ενθαρρύνουν τους προγραμματιστές να δημιουργούν και να χρησιμοποιούν κλάδους συχνά.

Ας δείτε γιατί πρέπει να το κάνετε αυτό. 

[NOTE]
.Δημιουργία κλάδου και μετάβαση σε αυτόν με τη μία.
====
Είναι σύνηθες όταν δημιουργείτε έναν κλάδο να θέλουμε να μεταβείτε σε αυτόν άμεσα -- αυτό μπορεί να γίνει με την εκτέλεση μίας μόνο εντολής, της `git checkout -b <όνομα-νέου-κλάδου>`.
====

[NOTE]
====
Από την έκδοση 2.23 του Git και μετά, μπορείτε να χρησιμοποιείτε την `git switch` αντί για `git checkout` ώστε:

- Να μεταβείτε σε έναν προϋπάρχοντα κλάδο: `git switch testing-branch`.
- Να δημιουργήσετε έναν νέο κλάδο και να μεταβείτε σε αυτόν: `git switch -c new-branch`.
  Η σημαία `-c` σημαίνει create, μπορείτε επίσης να χρησιμοποιείτε την πλήρη σημαία: `--create`.
- Να επιστρέψετε στον αμέσως προηγούμενο κλάδο που είχατε κάνει checkout: `git switch -`.
====
