[[r_git_branches_overview]]
=== Οι κλάδοι με λίγα λόγια

Για να κατανοήσουμε πραγματικά τον τρόπο με τον οποίο το Git υλοποιεί τις διακλαδώσεις, πρέπει πρώτα να εξετάσουμε τον τρόπο με τον οποίο το Git αποθηκεύει τα δεδομένα.

Όπως ίσως θυμόμαστε από την ενότητα <<ch01-getting-started#r_what_is_git_section>>, το Git δεν αποθηκεύει τα δεδομένα ως μία ακολουθία αλλαγών ή διαφορών αλλά ως μία ακολουθία _στιγμιότυπων_ (snapshots).

Όταν κάνουμε μία υποβολή (commit), το Git αποθηκεύει ένα αντικείμενο υποβολής που περιέχει έναν δείκτη προς το στιγμιότυπο του περιεχομένου που έχει υποβληθεί.
Αυτό το αντικείμενο περιέχει επίσης το όνομα και e-mail του συγγραφέα, το μήνυμα που έχουμε πληκτρολογήσει καθώς και δείκτες προς την υποβολή ή τις υποβολές που προηγήθηκαν ακριβώς πριν από αυτή την υποβολή (δηλαδή, τον γονέα ή τους γονείς της): όταν ένα αρχείο υποβάλλεται για πρώτη φορά, τότε δεν έχει κανέναν γονέα· μία συνηθισμένη υποβολή έχει έναν γονέα, ενώ μία υποβολή που προέκυψε από τη συγχώνευση δύο ή περισσότερων κλάδων έχει περισσότερους από έναν γονέα.

Για να το οπτικοποιήσουμε λίγο, ας υποθέσουμε ότι έχουμε έναν κατάλογο που περιέχει τρία αρχεία, τα οποία έχουμε προσθέσει στο στάδιο καταχώρησης και στη συνέχεια υποβάλλουμε (commit).
Κατά την προσθήκη των αρχείων στο στάδιο καταχώρησης υπολογίζονται τα αθροίσματα ελέγχου (checksums) των αρχείων (με τον αλγόριθμο SHA-1, που αναφέρθηκε στην ενότητα <<ch01-getting-started#r_what_is_git_section>>), αποθηκεύονται οι συγκεκριμένες εκδόσεις των αρχείων στο αποθετήριο Git (το Git ονομάζει αυτές τις εκδόσεις _blobs_) και προσθέτει τα αθροίσματα ελέγχου στο στάδιο καταχώρησης.

[source,console]
----
$ git add README test.rb LICENSE
$ git commit -m 'Initial commit'
----

Όταν κάνουμε την υποβολή, τρέχοντας την εντολή `git commit`, το Git υπολογίζει ένα άθροισμα ελέγχου για καθέναν υποκατάλογο (στη συγκεκριμένη περίπτωση μόνο για τον βασικό κατάλογο του έργου) και τους αποθηκεύει ως αντικείμενα δομής δένδρου στο αποθετήριο Git.
Στη συνέχεια το Git δημιουργεί ένα αντικείμενο υποβολής που περιέχει τα μεταδεδομένα και έναν δείκτη στη βάση του δένδρου του έργου, ώστε να μπορεί να επαναδημιουργήσει το στιγμιότυπο, όταν χρειαστεί.(((εντολές git, commit)))

Πλέον το αποθετήριό μας περιέχει πέντε αντικείμενα: τρία blob για τα περιεχόμενα των αρχείων (ένα blob για κάθε αρχείο), μία δομή δένδρου που καταγράφει τα περιεχόμενα του καταλόγου και προσδιορίζει ποιο αρχείο αντιστοιχίζεται σε ποιο blob και ένα αντικείμενο commit που περιέχει τον δείκτη στον βασικό κατάλογο και όλα τα μεταδεδομένα της υποβολής.

.Μια υποβολή και το δένδρο της
image::images/commit-and-tree.png[Μια υποβολή και το δένδρο της]

Αν κάνουμε μερικές αλλαγές και τις υποβάλλουμε, η επόμενη υποβολή αποθηκεύει έναν δείκτη στην ακριβώς προηγούμενη υποβολή.

.Υποβολές (commits) και οι γονείς τους.
image::images/commits-and-parents.png[Υποβολές (commits) και οι γονείς τους.]

Οι κλάδοι του Git είναι απλά μετακινήσιμοι δείκτες σε υποβολές. 
Το προεπιλεγμένο όνομα κλάδου στο Git είναι `master` (κύριος κλάδος).
Όταν ξεκινάμε να κάνουμε υποβολές, μας δίνεται ένας κλάδος `master` που δείχνει στην τελευταία υποβολή που κάναμε. 
Κάθε φορά που υποβάλλουμε, ο κλάδος `master` προχωρά αυτόματα.

[NOTE]
====
Ο κλάδος "`master`" στο Git δεν είναι κάποιος ειδικός κλάδος.(((master)))
Είναι ακριβώς το ίδιο με οποιονδήποτε άλλο κλάδο. 
Ο μόνος λόγος για τον οποίο σχεδόν κάθε αποθετήριο έχει έναν κλάδο `master` είναι επειδή η εντολή `git init` τον ονομάζει έτσι και οι περισσότεροι χρήστες του Git δεν ασχολούνται με το να τον αλλάξουν. 
====

.Ένας κλάδος και το ιστορικό υποβολών του
image::images/branch-and-history.png[Ένας κλάδος και το ιστορικό υποβολών του]

[[r_create_new_branch]]
==== Δημιουργία νέου κλάδου

(((κλάδοι, δημιουργία)))
Τι γίνεται όταν δημιουργούμε έναν νέο κλάδο; 
Αυτό που συμβαίνει είναι ότι δημιουργείται ένα νέος δείκτης τον οποίο μπορούμε να μετακινούμε από δω κι από κει.
Ας πούμε ότι δημιουργούμε έναν νέο κλάδο που ονομάζεται `testing`.
Αυτό γίνεται με την εντολή `git branch`:(((εντολές git, branch)))

[source,console]
----
$ git branch testing
----

Αυτή η εντολή δημιουργεί έναν νέο δείκτη στην υποβολή στην οποία βρισκόμαστε αυτή τη στιγμή. 

.Δύο κλάδοι που δείχνουν στην ίδια ακολουθία υποβολών
image::images/two-branches.png[Δύο κλάδοι που δείχνουν στην ίδια ακολουθία υποβολών]

Πώς όμως γνωρίζει το Git σε ποιον κλάδο βρισκόμαστε τώρα;
Το γνωρίζει επειδή διατηρεί έναν ειδικό δείκτη που ονομάζεται `HEAD`.
Σημειώνουμε ότι αυτός ο δείκτης `HEAD` είναι πολύ διαφορετικός από την έννοια του `HEAD` με την οποία είμαστε ενδεχομένως εξοικειωμένοι σε άλλα VCS, όπως το Subversion ή το CVS.
Στο Git αυτός είναι ένας δείκτης στον τοπικό κλάδο στον οποίο στον οποίο βρισκόμαστε αυτή τη στιγμή. 
Στη συγκεκριμένη περίπτωση, βρισκόμαστε ακόμα στον κλάδο `master`.
Η εντολή `git branch` απλά _δημιούργησε_ έναν νέο κλάδο -- δεν μετέβη σε αυτό τον κλάδο.

.Ο δείκτης HEAD δείχνει σε έναν κλάδο
image::images/head-to-master.png[Ο δείκτης HEAD δείχνει σε έναν κλάδο]

Αυτό μπορούμε να το διαπιστώσουμε εύκολα τρέχοντας την εντολή `git log` που παραθέτει πού δείχνουν οι δείκτες των κλάδων. 
Η επιλογή ονομάζεται`--decorate`,

[source,console]
----
$ git log --oneline --decorate
f30ab (HEAD -> master, testing) Add feature #32 - ability to add new formats to the central interface
34ac2 Fix bug #1328 - stack overflow under certain conditions
98ca9 Initial commit
----

Βλέπουμε τους κλάδους "`master`" και "`testing`" που βρίσκονται δίπλα στην υποβολή `f30ab`.

[[r_switching_branches]]
==== Μετάβαση σε άλλο κλάδο

(((κλάδοι, μετάβαση)))
Για να μεταβούμε σε έναν ήδη υπάρχοντα κλάδο, τρέχουμε την εντολή `git checkout`.(((εντολές git, checkout)))
Ας μεταβούμε στον νέο κλάδο `testing`:

[source,console]
----
$ git checkout testing
----

Η εντολή αυτή μετατοπίζει τον δείκτη `HEAD` ώστε να δείχνει στον κλάδο `testing`.

.Ο `HEAD` δείχνει στον τρέχοντα κλάδο.
image::images/head-to-testing.png[Ο `HEAD` δείχνει στον τρέχοντα κλάδο.]

Ποια είναι η σημασία αυτού του πράγματος;
Ας κάνουμε ακόμα μία υποβολή:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'Make a change'
----

.Ο κλάδος `HEAD` μετακινείται ότι γίνεται μία υποβολή
image::images/advance-testing.png[Ο κλάδος `HEAD` μετακινείται ότι γίνεται μία υποβολή]

Αυτό είναι ενδιαφέρον, διότι τώρα ο νέος μας κλάδος `testing` έχει προχωρήσει, αλλά ο κλάδος `master` ακόμα δείχνει στην υποβολή που βρισκόμασταν όταν είχαμε τρέξει την εντολή `git checkout` για να αλλάξουμε κλάδο. 
Ας επιστρέψουμε στον κλάδο `master`:

[source,console]
----
$ git checkout master
----

[NOTE]
.Η εντολή `git log` δεν δείχνει _όλους_ τους κλάδους _πάντα_
====
Αν εκτελούσατε `git log` τώρα, θα αναρωτιόσασταν πού πήγε ο κλάδος "testing" που μόλις δημιουργήσατε, αφού δεν θα εμφανιζόταν στην έξοδο της εντολής.

Ο κλάδος δεν έχει εξαφανιστεί· το Git δεν γνωρίζει ότι ενδιαφέροσαστε για αυτόν τον κλάδο και προσπαθεί να σας δείξει μόνο αυτό για το οποίο νομίζει ότι σας ενδιαφέρει.
Με άλλα λόγια, εξ ορισμού, η `git log` θα σας δείξει το ιστορικό υποβολών του κλάδου τον οποίο έχουμε κάνει checked out.

Για να δείτε όλο το ιστορικό υποβολών για τον κλάδο που θέλουμε, πρέπει να το πούμε ρητά: `git log testing`.
Για να δείτε το ιστορικό όλων των κλάδων, προσθέστε και το `--all` στην εντολή `git log`.
====

.Ο δείκτης `HEAD` μετακινείται όταν εκτελούμε checkout
image::images/checkout-master.png[Ο δείκτης `HEAD` μετακινείται όταν εκτελούμε checkout]

Αυτή η εντολή έκανε δύο πράγματα: 
Μετατόπισε τον δείκτη `HEAD` ώστε να ξαναδείχνει στον κλάδο `master` και επανέφερε τα αρχεία στον τρέχοντα κατάλογο στο στιγμιότυπο που δείχνει ο κλάδος `master'.
Αυτό σημαίνει επίσης ότι όποιες αλλαγές κάνουμε από αυτό το σημείο και μετά θα αποκλίνουν από μια παλιότερη έκδοση του έργου. 
Ουσιαστικά αναιρεί όποιες αλλαγές έχουμε κάνει στον κλάδο `testing` ώστε να μπορέσουμε να κινηθούμε σε μία διαφορετική κατεύθυνση.

[NOTE]
.Η μετάβαση από έναν κλάδο σε άλλον αλλάζει τα αρχεία στον κατάλογο εργασίας
===
Είναι σημαντικό να τονιστεί ότι όταν μετακινείστε από έναν κλάδο σε άλλο στο Git, τα αρχεία στον τρέχοντα κατάλογο αλλάζουν.
Αν μεταβείτε σε κάποιον παλιότερο κλάδο, ο τρέχων κατάλογος θα επαναφερθεί στην κατάσταση στην οποία βρισκόταν την τελευταία φορά που είχατε κάνει κάποια υποβολή σε αυτό τον κλάδο. 
Αν το Git δεν μπορεί να το κάνει χωρίς προβλήματα, δεν θα σας επιτρέψει να μεταβείτε σε αυτό τον κλάδο.
===

Ας κάνουμε μερικές ακόμα αλλαγές και να τις υποβάλλουμε:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'Make other changes'
----

Τώρα το ιστορικό του έργου έχει αποκλίνει (βλ. <<rdivergent_history>>).
Δημιουργήσαμε έναν κλάδο, μεταβήκαμε σε αυτόν, κάναμε κάποιες αλλαγές και μετά επιστρέψαμε στον κύριο κλάδο μας και κάναμε κάποιες άλλες αλλαγές.
Οι αλλαγές αυτές είναι απομονωμένες σε διαφορετικούς κλάδους: μπορούμε να μεταπηδούμε από τον έναν κλάδο στον άλλο και να τους συγχωνεύσουμε όταν είμαστε έτοιμοι. 
Και όλα αυτά τα καταφέρνουμε με απλές εντολές `branch`, `checkout` και `commit`.

[[rdivergent_history]]
.Αποκλίνον ιστορικό
image::images/advance-master.png[Αποκλίνον ιστορικό]

Αυτό μπορούμε επίσης να το δούμε εύκολα με την εντολή `git log`.
Αν εκτελέσουμε την εντολή `git log --oneline --decorate --graph --all` θα εκτυπωθεί το ιστορικό των υποβολών στο οποίο θα φαίνεται πού βρίσκονται οι δείκτες των κλάδων μας και με ποιον τρόπο έχει αποκλίνει το ιστορικό.

[source,console]
----
$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) Make other changes
| * 87ab2 (testing) Make a change
|/
* f30ab Add feature #32 - ability to add new formats to the central interface
* 34ac2 Fix bug #1328 - stack overflow under certain conditions
* 98ca9 Initial commit of my project
----

Επειδή ένας κλάδος στο Git είναι στην πραγματικότητα ένα αρχείο που περιέχει τους 40 χαρακτήρες του αθροίσματος ελέγχου SHA-1 της υποβολής στην οποία δείχνει, η δημιουργία και καταστροφή κλάδων είναι μία φθηνή διαδικασία.
Η δημιουργία ενός κλάδου είναι τόσο γρήγορη και απλή όσο το να γράφονται 41 byte σε ένα αρχείο (40 αλφαριθμητικοί χαρακτήρες και ένας χαρακτήρας αλλαγής γραμμής).

Αυτή είναι μία σημαντική διαφορά σε σχέση με τον τρόπο με τον οποίο τα περισσότερα παλιότερα VCS δημιουργούν κλάδους, που περιλαμβάνει την αντιγραφή όλων των αρχείων του έργου σε έναν άλλο κατάλογο. 
Αυτό μπορεί να διαρκέσει αρκετά δευτερόλεπτα ή ακόμα και λεπτά, ανάλογα με το μέγεθος του έργου, ενώ στο Git η διαδικασία είναι σχεδόν στιγμιαία. 
Επιπλέον, επειδή σε κάθε υποβολή καταγράφονται οι γονείς της, η εύρεση μίας κατάλληλης βάσης για συγχώνευση γίνεται αυτόματα και γενικά πολύ εύκολα.
Αυτά τα χαρακτηριστικά ενθαρρύνουν τους προγραμματιστές να δημιουργούν και να χρησιμοποιούν κλάδους συχνά.

Ας δούμε γιατί πρέπει να το κάνουμε αυτό. 

[NOTE]
.Δημιουργία κλάδου και μετάβαση σε αυτόν με τη μία
====
Είναι σύνηθες όταν δημιουργείτε έναν κλάδο να θέλετε να μεταβείτε σε αυτόν άμεσα -- αυτό μπορεί να γίνει με την εκτέλεση μίας μόνο εντολής, της `git checkout -b <newbranchname>`.
====

[NOTE]
====
Από την έκδοση 2.23 του Git και μετά, μπορείτε να χρησιμοποιήσετε την `git switch` αντί για `git checkout` ώστε:

- Να μεταβείτε σε έναν προϋπάρχοντα κλάδο: `git switch testing-branch`.
- Να δημιουργήσετε έναν νέο κλάδο και να μεταβείτε σε αυτόν: `git switch -c new-branch`.
  Η σημαία `-c` σημαίνει create, μπορείτε επίσης να χρησιμοποιήσετε την πλήρη σημαία: `--create`.
- Να επιστρέψετε στον αμέσως προηγούμενο κλάδο που είχατε κάνει checkout: `git switch -`.
====
