[[r_rebasing]]
=== Αλλαγή βάσης (rebasing)

(((επανατοποθέτηση)))(((αλλαγή βάσης)))(((rebasing)))
Στο Git, υπάρχουν δύο βασικοί τρόποι ενσωμάτωσης αλλαγών από έναν κλάδο σε έναν άλλο: με την εντολή `merge` και την εντολή `rebase` (αλλαγή βάσης).
Σε αυτή την ενότητα θα μάθετε τι είναι η αλλαγή βάσης, πώς την κάνετε, γιατί θεωρείται εκπληκτικό εργαλείο και σε ποιες περιπτώσεις δεν πρέπει να τη χρησιμοποιήσετε.

==== Η βασική μορφή αλλαγής βάσης

Εάν επιστρέψετε σε ένα παλαιότερο παράδειγμα από την ενότητα <<r_basic_merging>>, θα δείτε ότι η δουλειά σας είχε αποκλίνει και είχατε κάνει υποβολές σε δύο διαφορετικούς κλάδους.

.Απλό αποκλίνον ιστορικό.
image::images/basic-rebase-1.png[Απλό αποκλίνον ιστορικό.]

Ο ευκολότερος τρόπος ενσωμάτωσης των κλάδων, όπως έχουμε ήδη δει, είναι η εντολή `merge` (συγχώνευση).
Επιτελεί μια τριμερή συγχώνευση μεταξύ των δύο τελευταίων στιγμιότυπων διακλάδωσης (`C3` και`C4`) και του πιο πρόσφατου κοινού προγόνου τους (`C2`), δημιουργώντας ένα νέο στιγμιότυπο (και μία νέα υποβολή).

.Συγχώνευση και ενσωμάτωση αποκλίνοντος ιστορικού εργασίας.
image::images/basic-rebase-2.png[Συγχώνευση και ενσωμάτωση αποκλίνοντος ιστορικού εργασίας.]

Ωστόσο, υπάρχει κι ένας άλλος τρόπος: μπορείτε να πάρετε μόνον το επίθεμα (patch) με τις τροποποιήσεις που εισήχθησαν με την υποβολή `C4` και να το εφαρμόσετε ξανά στο στιγμιότυπο `C3`.
Στο Git, αυτό ονομάζεται _αλλαγή βάσης_ ή _επανατοποθέτηση_ (rebasing).
Με την εντολή `rebase` παίρνετε όλες τις αλλαγές που υποβλήθηκαν σε ένα κλάδο και να τις επαναλαμβάνετε σε έναν άλλο.(((εντολές git, rebase)))

Για αυτό το παράδειγμα, πρώτα θα κάνατε checkout τον κλάδο `experiment` και στη συνέχεια θα τον επανατοποθετούσατε στον κλάδο `master` (δηλαδή, θα αλλάζατε τη βάση του από την υποβολή `C2` στην υποβολή που δείχνει ο κλάδος `master`) ως εξής:

[source,console]
----
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
----

Η διαδικασία που ακολουθείται με την εντολή `rebase` είναι η εξής: μεταβαίνει στον κοινό πρόγονο των δύο κλάδων (εκείνου στον οποίο βρίσκεστε και εκείνου ο οποίος θα γίνει η νέα βάση), παίρνει τις διαφορές (diff) που εισάγονται από κάθε υποβολή του κλάδου στον οποίο βρίσκεστε, αποθηκεύει αυτές τις διαφορές σε προσωρινά αρχεία, μετατοπίζει τον τρέχοντα κλάδο στην ίδια υποβολή στην οποία βρίσκεται και ο κλάδος ο οποίος θα γίνει η νέα βάση και, τέλος, εφαρμόζει τις αλλαγές τη μία μετά την άλλη διαδοχικά.

.Αλλαγή της βάσης των τροποποιήσεων της `C4` από τη `C2` στη `C3`.
image::images/basic-rebase-3.png[Αλλαγή της βάσης των τροποποιήσεων της `C4` από τη `C2` στη `C3`.]

Σε αυτό το σημείο, μπορείτε να επιστρέψετε στον κλάδο `master` και να κάνετε μία συγχώνευση με ταχυπροώθηση.

[source,console]
----
$ git checkout master
$ git merge experiment
----

.Ταχυπροώθηση του κλάδου `master`.
image::images/basic-rebase-4.png[Ταχυπροώθηση του κλάδου `master`.]

Πλέον το στιγμιότυπο στο οποίο δείχνει η υποβολή `C4'` είναι ακριβώς ίδιο με αυτό στο οποίο δείχνει η `C5` στο παλιότερο παράδειγμα με τη συγχώνευση.
Το τελικό προϊόν της ενσωμάτωσης των αλλαγών είναι ακριβώς το ίδιο, αλλά η αλλαγή της βάσης κρατά το ιστορικό πιο καθαρό.
Αν εξετάσετε το log ενός επανατοποθετημένου (σε νέα βάση) κλάδου, φαίνεται σαν το ιστορικό να είναι γραμμικό, δηλαδή σαν όλη η εργασία να συνέβη ακολουθιακά παρά το ότι αρχικά γινόταν παράλληλα.

Συχνά θα κάνετε κάτι τέτοιο για να βεβαιωθείτε ότι οι υποβολές σας εφαρμόζονται χωρίς συγκρούσεις σε έναν απομακρυσμένο κλάδο -- ενδεχομένως σε ένα έργο στο οποίο συμβάλλετε, αλλά δεν το διαχειρίζεστε.
Σε μία τέτοια περίπτωση, θα κάνατε τη δουλειά σας σε έναν κλάδο και στη συνέχεια θα αλλάζατε τη βάση (επανατοποθετούσατε) της εργασίας σας στον κλάδο `origin/master` όταν ήσασταν έτοιμοι να υποβάλλετε τα επιθέματά σας στο κύριο έργο.
Με αυτό τον τρόπο, ο διαχειριστής του έργου δεν χρειάζεται να κάνει καμία εργασία ενσωμάτωσης -- απλά μια ταχυπροώθηση ή μια καθαρή εφαρμογή.

Σημειώστε ότι το στιγμιότυπο στο οποίο δείχνει η υποβολή στην οποία καταλήγετε, είναι το ίδιο είτε πρόκειται για την τελευταία από τις επανατοποθετημένες υποβολές μετά από αλλαγή βάσης είτε για την τελική υποβολή συγχώνευσης μετά από μία συγχώνευση -- το μόνο που είναι διαφορετικό είναι το ιστορικό.
Η αλλαγή βάσης εφαρμόζει τις τροποποιήσεις μίας γραμμής εργασίας σε μία άλλη με τη σειρά που έγιναν, ενώ η συγχώνευση παίρνει τα τελικά στιγμιότυπα και τα συγχωνεύει.

==== Μερικές ενδιαφέρουσες αλλαγές βάσης

Μπορείτε επίσης να επανατοποθετήσετε έναν κλάδο πάνω σε κάποιον κλάδο διαφορετικό από αυτόν στον οποίο βασιζόταν αρχικά.
Για παράδειγμα, ας πάρουμε ένα ιστορικό όπως αυτό στο <<rrbdiag_e>>.
Έχετε δημιουργήσει έναν θεματικό κλάδο (`server`) για να προσθέσετε κάποια λειτουργικότητα από την πλευρά του διακομιστή στο έργο σας και πραγματοποιήσατε μια υποβολή.
Στη συνέχεια, δημιουργήσατε μία ακόμα διακλάδωση για να κάνετε τις αλλαγές από την πλευρά του πελάτη (`client`) και κάνατε επίσης μερικές υποβολές.
Τέλος, επιστρέψατε στον κλάδο `server` και κάνατε μερικές ακόμη υποβολές.

[[rrbdiag_e]]
.Ιστορικό με έναν θεματικό κλάδο που βασίζεται σε έναν άλλο θεματικό κλάδο
image::images/interesting-rebase-1.png[Ιστορικό με έναν θεματικό κλάδο που βασίζεται σε έναν άλλο θεματικό κλάδο]

Ας υποθέσουμε ότι αποφασίζετε να συγχωνεύσετε τις αλλαγές από την πλευρά του πελάτη στην κεντρική γραμμή που θα δημοσιευτεί, αλλά θέλετε να αναβάλλετε τις αλλαγές από την πλευρά του διακομιστή μέχρι να εξεταστούν περαιτέρω.
Μπορείτε να πάρετε τις αλλαγές από τον κλάδο `client` που δεν βρίσκονται στον κλάδο `server` (`C8` και`C9`) και να τις αναπαράγετε στον κύριο κλάδο σας χρησιμοποιώντας την επιλογή `--onto` της `git rebase`:

[source,console]
----
$ git rebase --onto master server client
----

Αυτή η εντολή ουσιαστικά λέει, "`Πήγαινε στον κλάδο `client`, εντόπισε τα επιθέματα από τότε που απέκλινε από τον κλάδο `server` και εφάρμοσέ τα στον κλάδο `client` σαν ο κλάδος `client` να ήταν κλάδος που απέκλινε από τον κλάδο `master``".
Είναι λίγο περίπλοκο, αλλά το αποτέλεσμα είναι μια ομορφιά.

.Αλλαγή βάσης ενός θεματικού κλάδου που βασίζεται σε έναν άλλο θεματικό κλάδο.
image::images/interesting-rebase-2.png[Αλλαγή βάσης ενός θεματικού κλάδου που βασίζεται σε έναν άλλο θεματικό κλάδο.]

Τώρα μπορείτε να ταχυπροωθήσετε τον κλάδο `master` (βλ. <<rrbdiag_g>>):

[source,console]
----
$ git checkout master
$ git merge client
----

[[rrbdiag_g]]
.Ταχυπροώθηση του κλάδου `master` ώστε να συμπεριλάβει τις αλλαγές του κλάδου `client`.
image::images/interesting-rebase-3.png[Ταχυπροώθηση του κλάδου `master` ώστε να συμπεριλάβει τις αλλαγές του κλάδου `client`.]

Ας πείτε ότι τώρα αποφασίζετε να ενσωματώσετε και τις αλλάγες του κλάδου `server`.
Μπορείτε να αλλάξετε τη βάση του κλάδου `server` (στον κλάδο `master`), χωρίς να έχετε προηγουμένως μεταβεί σε αυτόν, εκτελώντας την εντολή `git rebase <νέα-βάση> <θεματικός-κλάδος>`, η οποία σας μεταφέρει στον θεματικό κλάδο (σε αυτή την περίπτωση, τον `server`) και εφαρμόζει τις αλλαγές του στη νέα βάση (`master`) συγχρόνως:
[source,console]
----
$ git rebase master server
----

Το αποτέλεσμα της παραπάνω εντολής φαίνεται στην <<rrbdiag_h>>.

[[rrbdiag_h]]
.Αλλαγή της βάσης του κλάδου `server` στον κλάδο `master`.
image::images/interesting-rebase-4.png[Αλλαγή της βάσης του κλάδου `server` στον κλάδο `master`.]

Στη συνέχεια μπορείτε να ταχυπροωθήσετε τον κλάδο-βάση (`master`):

[source,console]
----
$ git checkout master
$ git merge server
----

Μπορείτε να αφαιρέσετε τους κλάδους `client` και `server` επειδή όλη δουλειά σας έχει ενσωματωθεί και δεν τους χρειάζεστε πια. 
Κάτι τέτοιο θα κάνει το ιστορικό σας, μετά από όλη αυτή τη διαδικασία, να μοιάζει με το <<rrbdiag_i>>:

[source,console]
----
$ git branch -d client
$ git branch -d server
----

[[rrbdiag_i]]
.Τελικό ιστορικό υποβολών.
image::images/interesting-rebase-5.png[Τελικό ιστορικό υποβολών.]

[[r_rebase_peril]]
==== Οι κίνδυνοι της αλλαγής βάσης

(((αλλαγή βάσης, κίνδυνοι)))
Όμως η ευδαιμονία που σας προσφέρει η αλλαγή βάσης έχει κάποιο αντίτιμο, το οποίο μπορεί να συνοψιστεί σε μία γραμμή:

*Δεν αλλάζετε τη βάση υποβολών που υπάρχουν εκτός του αποθετηρίου σας.*

Αν ακολουθήσετε αυτή τη συμβουλή, θα είστε μια χαρά.
Αν δεν το κάνετε, θα γίνετε μισητοί σε όλη την οικουμένη και θα σας περιφρονήσουν φίλοι και συγγενείς.

Όταν αλλάζετε τη βάση ενός κλάδου, εγκαταλείπετε τις υπάρχουσες υποβολές και δημιουργείτε νέες που είναι παρόμοιες μεν, διαφορετικές δε.
Εάν ωθήσετε υποβολές κάπου και άλλοι τις τραβήξουν και βασίσουν τη δουλειά τους σε αυτές και στη συνέχεια ξαναγράψετε αυτές τις υποβολές με την `git rebase` και τις ωθήσετε ξανά, οι συνεργάτες σας θα πρέπει να ξανασυγχωνεύσουν τη δουλειά τους και τα πράγματα θα μπλέξουν όταν προσπαθήσετε να ελκύσετε τη δουλειά τους στη δική σας.

Ας δείτε ένα παράδειγμα του τρόπου με τον οποίο η αλλαγή της βάσης κάποιας εργασίας που έχετε ήδη κοινοποιήσει σε άλλους μπορεί να προκαλέσει προβλήματα.
Ας υποθέσουμε ότι κλωνοποιείτε από έναν κεντρικό διακομιστή και στη συνέχεια κάνετε κάποιες αλλαγές.
Το ιστορικό της υποβολής σας μοιάζει με αυτό:

.Κλωνοποίηση αποθετηρίου και επεξεργασία του.
image::images/perils-of-rebasing-1.png[Κλωνοποίηση αποθετηρίου και επεξεργασία του.]

Τώρα, κάποιος άλλος κάνει και άλλη δουλειά που περιλαμβάνει συγχώνευση και ωθεί τη δουλειά του στον κεντρικό διακομιστή.
Την ανακτάτε και συγχωνεύετε τον νέο απομακρυσμένο κλάδο στη δουλειά σας, κάνοντας το ιστορικό σας να μοιάζει με αυτό:

.Ανάκτηση περισσότερων υποβολών και συγχώνευσή τους στην εργασία σας.
image::images/perils-of-rebasing-2.png[Ανάκτηση περισσότερων υποβολών και συγχώνευσή τους στην εργασία σας.]

Στη συνέχεια, αυτός που ώθησε τη συγχωνευμένη δουλειά αποφασίζει να επιστρέψει και να αλλάξει τη βάση της εργασίας του· κάνει `git push --force` για να επανεγγράψει το ιστορικό στον διακομιστή.
Στη συνέχεια, ανακτάτε από τον διακομιστή και φέρνετε τις νέες υποβολές.

[[r_pre_merge_rebase_work]]
.Κάποιος ωθεί επανατοποθετημένες υποβολές, εγκαταλείποντας τις υποβολές στις οποίες έχετε βασίσει τη δουλειά σας.
image::images/perils-of-rebasing-3.png[Κάποιος ωθεί επανατοποθετημένες υποβολές, εγκαταλείποντας τις υποβολές στις οποίες έχετε βασίσει τη δουλειά σας.]

Τώρα έχετε μπλέξει άσχημα.
Εάν κάνετε `git pull`, θα δημιουργήσετε μια υποβολή συγχώνευσης που συμπεριλαμβάνει και τις δύο γραμμές του ιστορικού και το αποθετήριό σας θα μοιάζει με αυτό:

[[r_merge_rebase_work]]
.Συγχώνευση της ίδιας εργασίας σε μία νέα υποβολή συγχώνευσης.
image::images/perils-of-rebasing-4.png[Συγχώνευση της ίδιας εργασίας σε μία νέα υποβολή συγχώνευσης.]

Αν το ιστορικό σας μοιάζει με το παραπάνω και τρέξετε `git log`, θα δείτε δύο υποβολές που έχουν τον ίδιο συγγραφέα, ημερομηνία και μήνυμα, κάτι που μπορεί να προκαλέσει σύγχυση.
Επιπλέον, αν ωθήσετε αυτό το ιστορικό πίσω στον διακομιστή, θα επαναφέρετε όλες εκείνες τις επανατοποθετημένες υποβολές στον κεντρικό εξυπηρετητή, κάτι που θα μπερδέψει ακόμα περισσότερο τους υπόλοιπους.
Είναι αρκετά σίγουρο ότι ο άλλος προγραμματιστής δεν θέλει οι `C4` και `C6` να βρίσκονται στο ιστορικό· άλλωστε αυτός είναι ο λόγος για τον οποίο έκανε την αλλαγή της βάσης.

[[r_rebase_rebase]]
==== Επανατοποθέτηση σε επανατοποθετημένες υποβολές
Αν παρόλα αυτά, *όντως* βρεθείτε σε μια τέτοια κατάσταση, το Git διαθέτει κάποια μαγικά κόλπα που θα μπορούν να σας βοηθήσουν.
Εάν κάποιος από την ομάδα σας ωθεί εξαναγκαστικά αλλαγές που επανεγγράφουν εργασία στην οποία βασίσατε τη δική σας δουλειά, το πρόβλημά σας ανάγεται στο να εντοπίσετε τι είναι δικό σας και τι έχει ξαναγραφτεί από αυτό.

Το Git εκτός από το άθροισμα ελέγχου SHA-1 υπολογίζει επίσης ένα άθροισμα ελέγχου που βασίζεται ακριβώς στο επίθεμα που εισήχθη με την υποβολή.
Αυτό ονομάζεται "`patch-id`" (ταυτότητα επιθέματος).

Αν τραβήξετε εργασία που ξαναγράφτηκε και αλλάξετε τη βάση του δικού σας κλάδου ώστε αυτός να βασίζεται πάνω στις νέες υποβολές του συνεργάτη σας, το Git μπορεί συχνά να καταλάβει ποιες αλλαγές είναι μόνο δικές σας και να τις εφαρμόσει ξανά στον νέο κλάδο.

Για παράδειγμα, αν στο προηγούμενο σενάριο, όταν βρίσκεστε στο <<r_pre_merge_rebase_work>> αντί να κάνετε συγχώνευση, τρέξετε `git rebase teamone/master`, το Git:

* Θα προσδιορίσει ποια δουλειά βρίσκεται μόνον στον κλάδο σας (`C2`, `C3`, `C4`, `C6`, `C7`)
* Θα προσδιορίσει ποιες υποβολές δεν είναι υποβολές συγχώνευσης (`C2`, `C3`, `C4`)
* Θα προσδιορίσει ποιες υποβολές δεν έχουν ξαναγραφτεί στον κλάδο στόχο (μόνο οι `C2` και `C3`, δεδομένου ότι η `C4` είναι το ίδιο επίθεμα με την `C4'`)
* Θα εφαρμόσει αυτές τις υποβολές στον κλάδο `teamone/master`.

Έτσι, αντί για το αποτέλεσμα που βλέπουμε στην <<r_merge_rebase_work>>, θα καταλήγαμε σε κάτι που μοιάζει πιο πολύ με την <<r_rebase_rebase_work>>.

[[r_rebase_rebase_work]]
.Επανατοποθέτηση πάνω σε εξαναγκασμένα επανατοποθετημένη εργασία.
image::images/perils-of-rebasing-5.png[Επανατοποθέτηση πάνω σε εξαναγκασμένα επανατοποθετημένη εργασία.]

Αυτό θα έχει το επιθυμητό αποτέλεσμα μόνον εάν οι `C4` και `C4'` που έφτιαξε ο συνεργάτης σας είναι σχεδόν ακριβώς το ίδιο επίθεμα.
Διαφορετικά, η `git rebase` δεν θα είναι σε θέση να καταλάβει ότι πρόκειται για ουσιαστικά την ίδια υποβολή και θα προσθέσει ένα ακόμη επίθεμα παρόμοιο με το `C4` (το οποίο πιθανότατα θα αποτύχει να εφαρμοστεί χωρίς συγκρούσεις, αφού οι αλλαγές θα έχουν, τουλάχιστον εν μέρει, εφαρμοστεί ήδη).

Μπορείτε επίσης να απλοποιήσετε τη διαδικασία τρέχοντας μία `git pull --rebase` αντί για  κανονικό `git pull`.
Ή θα μπορούσατε να το κάνετε χειροκίνητα με μία `git fetch` ακολουθούμενο από μία `git rebase teamone/master` στη συγκεκριμένη περίπτωση.

Εάν χρησιμοποιείτε την `git pull` και θέλετε να κάνετε `--rebase` την προεπιλογή, μπορείτε να ορίσετε την τιμή της παραμέτρου `pull.rebase` με κάτι σαν `git config --global pull.rebase true`.

Αν αλλάζετε τη βάση υποβολών που δεν έχουν φύγει ποτέ από τον υπολογιστή σας, δεν θα έχετε προβλήματα.
Εάν αλλάζετε τη βάση υποβολών που έχουν ήδη ωθηθεί δημοσίως και κάποιοι άλλοι έχουν βασίσει μέρος της εργασίας τους σε αυτές τις υποβολές, τότε μπορεί να αντιμετωπίσετε προβλήματα που θα προκαλέσουν στους συνεργάτες σας αγανάκτηση και περιφρόνηση προς το πρόσωπό σας.

Αν αυτό θεωρηθεί απαραίτητο σε κάποιο σημείο, θα πρέπει να βεβαιωθείτε ότι όλοι έχουν ενημερωθεί να εκτελέσουν την `git pull --rebase` ώστε να καταπραΰνετε λίγο τον πόνο που θα ακολουθήσει.


==== Σύγκριση αλλαγής βάσης και συγχώνευσης

(((αλλαγή βάσης, σύγκριση με συγχώνευση)))(((συγχώνευση, σύγκριση με αλλαγή βάσης)))(((επανατοποθέτηση, σύγκριση με συγχώνευση)))(((συγχώνευση, σύγκριση με επανατοποθέτηση)))(((rebasing, vs. merging)))(((merging, vs. rebasing)))
Τώρα που έχετε δει την αλλαγή βάσης και τη συγχώνευση σε δράση, ίσως να αναρωτιέστε ποια διαδικασία είναι καλύτερη.
Πριν απαντήσουμε σε αυτό το ερώτημα, ας θυμηθείτε τι ακριβώς είναι το ιστορικό.

Μια θεώρηση του πράγματος είναι ότι το ιστορικό των υποβολών του αποθετηρίου σας είναι *καταγραφή όσων πραγματικά συνέβησαν*.
Είναι ένα ιστορικό έγγραφο, πολύτιμο από μόνο του και δεν πρέπει να παραβιάζεται.
Από αυτή τη σκοπιά, η αλλαγή του ιστορικού των υποβολών αποτελεί σχεδόν βλασφημία. 
Λέτε _ψέματα_ για το τι πραγματικά συνέβη.
Τι γίνεται, λοιπόν, αν υπάρχει μια μπουρδουκλωμένη σειρά υποβολών συγχώνευσης;
Αυτός είναι ο τρόπος με τον οποίο συνέβησαν και το αποθετήριο πρέπει να τη διατηρήσει για πάντα.

Η αντίθετη άποψη είναι ότι το ιστορικό της υποβολής είναι η *ένα αφήγημα του πώς έγινε το έργο σας*.
Δεν θα δημοσιεύατε το προσχέδιο ενός βιβλίου, οπότε γιατί να δείξετε όλη thn τσαπατσούλικη δουλειά;
Όταν εργάζεστε σε ένα έργο, ίσως χρειάζεστε μια καταγραφή όλων λανθασμένων βημάτων και των αδιεξόδων, αλλά όταν φτάνει η ώρα να δείξετε τη δουλειά σας στον υπόλοιπο κόσμο, ίσως θέλετε να πείτε μια πιο συνεκτική ιστορία του πώς πήγατε από το Α στο Β. 
Όσοι βρίσκονται σε αυτό το στρατόπεδο χρησιμοποιούν εργαλεία όπως `rebase` και `filter-branch` για να ξαναγράψουν τις υποβολές τους πριν αυτές συγχωνευτούν στον κύριο κλάδο.
Χρησιμοποιούν εργαλεία όπως `rebase` και `filter-branch` για να αφηγηθούν την ιστορία με αυτόν τον τρόπο που είναι ο καλύτερος για τους μελλοντικούς αναγνώστες.

Τώρα, στο ερώτημα τι είναι καλύτερο, η συγχώνευση ή αλλαγή βάσης; Ας ελπίσουμε ότι βλέπετε ότι η απάντηση δεν είναι τόσο απλή.
Το Git είναι ένα ισχυρό εργαλείο και σας επιτρέπει να κάνετε πολλά πράγματα στο ιστορικό ή με το ιστορικό, αλλά κάθε ομάδα και κάθε έργο είναι διαφορετικά.
Εφόσον γνωρίζετε πώς λειτουργούν και οι δύο αυτές διαδικασίες, μπορείτε να αποφασίσετε ποια είναι η καλύτερη σε κάθε περίσταση.

Μπορείτε να συνδυάσετε και τα δύο: να επανατοποθετείτε τοπικές αλλαγές που δεν έχετε κοινοποιήσει σε άλλους, προκειμένου να καθαρίσετε το ιστορικό σας, αλλά ποτέ να μην επανατοποθετείτε τίποτα που έχετε ήθη ωθήσει κάπου.
