[[r_remote_branches]]
=== Απομακρυσμένοι κλάδοι

(((κλάδοι, απομακρυσμένοι)))(((αναφορές, απομακρυσμένες)))
Οι απομακρυσμένες αναφορές είναι αναφορές (δείκτες) που βρίσκονται στα απομακρυσμένα αποθετήριά μας και συμπεριλαμβάνουν κλάδους, ετικέτες και ούτω καθεξής.
Μπορούμε να πάρουμε μία πλήρη λίστα των απομακρυσμένων αναφορών με την εντολή `git ls-remote <remote>` ή `git remote show <remote>` για απομακρυσμένους κλάδους καθώς και άλλες πληροφορίες.
Παρόλα αυτά, ένας πιο συνηθισμένος τρόπος είναι να εκμεταλλευτούμε τους κλάδους απομακρυσμένης παρακολούθησης (remote-tracking branches).

Οι κλάδοι απομακρυσμένης παρακολούθησης είναι αναφορές στην κατάσταση απομακρυσμένων κλάδων.
Είναι τοπικές αναφορές τις οποίες δεν μπορούμε να μετακινήσουμε· μετακινούνται αυτόματα όποτε υπάρχει κάποια δικτυακή επικοινωνία, ώστε να διασφαλίζεται η ακριβής αναπαράσταση της κατάστασης του απομακρυσμένου αποθετηρίου.
Μπορούμε να τους σκέφτομαστε ως σελιδοδείκτες που μας θυμίζουν πού βρίσκονταν οι κλάδοι στα απομακρυσμένα αποθετήριά μας την τελευταία φορά που είχαμε συνδεθεί σε αυτά.

Έχουν τη μορφή `<απομακρυσμένο-αποθετήριο>/<κλάδος>` (`<remote>/<branch>`).
Για παράδειγμα, αν θέλουμε να δούμε σε ποια κατάσταση ήταν ο κλάδος `master` στο απομακρυσμένο αποθετήριό μας `origin` την τελευταία φορά που επικοινωνήσαμε μαζί του, θα πρέπει να μεταβούμε στον κλάδο `origin/master`.
Αν δουλεύαμε σε ένα θέμα με κάποιον συνεργάτη και αυτός είχε ωθήσει έναν κλάδο `iss53`, ενδεχομένως να είχαμε κι εμείς έναν δικό μας τοπικό κλάδο `iss53`, αλλά ο κλάδος στον διακομιστή θα αναπαρίστατο με τον κλάδο απομακρυσμένης παρακολούθησης `origin/iss53`.

Ίσως όλα αυτά φαίνονται συγκεχυμένα, οπότε ας τα ξεμπερδέψουμε με ένα παράδειγμα. 
Ας υποθέσουμε ότι έχουμε έναν διακομιστή Git στο δίκτυό μας στη διεύθυνση `git.ourcompany.com`.
Αν τον κλωνοποιήσουμε, η εντολή `clone` του Git θα τον ονομάσει `origin`, θα τραβήξει όλα τα δεδομένα και θα δημιουργήσει έναν δείκτη που δείχνει εκεί όπου βρίσκεται ο κλάδος του `master` και θα τον ονομάσει τοπικά `origin/master`.
Το Git επίσης θα δημιουργήσει έναν τοπικό κλάδο `master` για εμάς, ώστε να έχουμε έναν κλάδο στον οποίο μπορούμε να δουλέψουμε. Αυτός ο κλάδος ξεκινά από το ίδιο σημείο από όπου ξεκινά και ο κλάδος `master` του αποθετηρίου `origin`.

[NOTE]
====
.Το αποθετήριο "`origin`" δεν είναι κάτι ιδιαίτερο
Ακριβώς όπως το όνομα κλάδου "`master`" δεν έχει κάποια ιδιαίτερη σημασία στο Git, το ίδιο συμβαίνει και με το όνομα κλάδου "`origin`".
Ενώ "`master`" είναι το προεπιλεγμένο όνομα για τον αρχικό κλάδο όταν τρέχουμε την εντολή `git init` (που είναι και ο μόνος λόγος για τον οποίο χρησιμοποιείται τόσο ευρέως), "`origin`" είναι το προεπιλεγμένο όνομα για ένα απομακρυσμένο αποθετήριο όταν τρέχουμε `git clone`.
Αν τρέξουμε `git clone -o booyah` τότε θα έχουμε ως προεπιλεγμένο απομακρυσμένο κλάδο τον `booyah/master`.(((origin)))
====

.Τοπικά και απομακρυσμένα αποθετήρια μετά την κλωνοποίηση
image::images/remote-branches-1.png[Τοπικά και απομακρυσμένα αποθετήρια μετά την κλωνοποίηση]

Αν κάνουμε λίγη δουλίτσα στον τοπικό μας κλάδο `master` και στο μεταξύ κάποιος άλλος ωθήσει στο `git.ourcompany.com` και ενημερώσει τον κλάδο `master`, τότε τα δύο ιστορικά θα προχωρήσουν διαφορετικά.
Επιπλέον, για όσο χρονικό διάστημε δεν είμαστε συνδεδεμένοι με τον διακομιστή `origin`, ο δείκτης μας `origin/master` δεν μετακινείται.

.Η τοπική και απομακρυσμένη δουλειά μπορεί να αποκλίνουν
image::images/remote-branches-2.png[Η τοπική και απομακρυσμένη δουλειά μπορεί να αποκλίνουν]

Για να συγχρονίσουμε τη δουλειά μας με κάποιο απομακρυσμένο αποθετήριο, τρέχουμε την εντολή `git fetch <remote>` (στην περίπτωσή μας `git fetch <origin>`).
Αυτή η εντολή αναζητά ποιος διακομιστής είναι ο "`origin`" (στη συγκεκριμένη περίπτωση είναι ο `git.ourcompany.com`), ανακτά (fetch) από αυτόν ό,τι δεδομένα δεν έχουμε ακόμα και ενημερώνει την τοπική βάση δεδομένων μας, μετακινώντας τον δείκτη `origin/master` στη νέα του πιο ενημερωμένη θέση.

.Η εντολή `git fetch` ενημερώνει τους κλάδους απομακρυσμένης παρακολούθησης
image::images/remote-branches-3.png[Η εντολή `git fetch` ενημερώνει τους κλάδους απομακρυσμένης παρακολούθησης]

Για να δείξουμε τι συμβαίνει όταν έχουμε πολλούς απομακρυσμένους διακομιστές και με τι μοιάζουν οι απομακρυσμένοι κλάδοι των απομακρυσμένων έργων, ας υποθέσουμε ότι έχουμε ένα άλλο εσωτερικό διακομιστή Git που χρησιμοποιείται μόνον για ανάπτυξη κώδικα από μία συγκεκριμένη ομάδα.
Αυτός ο διακομιστής βρίσκεται στη διεύθυνση `git.team1.ourcompany.com`.
Μπορούμε να τον προσθέσουμε στο έργο στο οποίο δουλεύουμε ως μία νέα απομακρυσμένη αναφορά εκτελώντας την εντολή `git remote add` όπως εξηγήσαμε στο κεφάλαιο <<ch02-git-basics-chapter#ch02-git-basics-chapter>>.
Ονομάστε αυτό τον απομακρυσμένο διακομιστή `teamone`, που θα είναι και το σύντομο όνομα του παραπάνω URL.

.Προσθήκη ενός επιπλέον απομακρυσμένου διακομιστή
image::images/remote-branches-4.png[Προσθήκη ενός επιπλέον απομακρυσμένου διακομιστή]

Τώρα μπορούμε να τρέξουμε την εντολή `git fetch teamone` για να ανακτήσουμε οτιδήποτε ο απομακρυσμένος διακομιστής `teamone` έχει που δεν το έχουμε ακόμα εμείς.
Επειδή ο διακομιστής έχει ένα υποσύνολο από τα δεδομένα που έχει ο διακομιστής `origin` αυτή τη στιγμή, το Git δεν ανακτά δεδομένα, αλλά τοποθετεί έναν κλάδο απομακρυσμένης παρακολούθησης με όνομα `teamone/master` να δείχνει στην υποβολή που έχει ο `teamone` στον δικό του κλάδο `master`.

.Κλάδος απομακρυσμένης παρακολούθησης για τον κλάδο `teamone/master`
image::images/remote-branches-5.png[Κλάδος απομακρυσμένης παρακολούθησης για τον κλάδο `teamone/master`]

[[r_pushing_branches]]
==== Ωθήσεις

(((ώθηση)))(((pushing)))
Όταν θέλουμε να μοιραστούμε έναν κλάδο με τον υπόλοιπο κόσμο, πρέπει να τον ωθήσουμε σε έναν απομακρυσμένο διακομιστή στον οποίο έχουμε δικαίωμα εγγραφής (write access).
Οι τοπικοί μας κλάδοι δεν συγχρονίζονται αυτόματα με τους απομακρυσμένους διακομιστές στους οποίους έχουμε δικαίωμα να αποθηκεύσουμε -- πρέπει να ωθήσουμε χειροκίνητα τους κλάδους που θέλουμε να κοινοποιήσουμε σε άλλους.
Με αυτό τον τρόπο, μπορούμε να χρησιμοποιήσουμε ιδιωτικούς κλάδους για δουλειά που δεν θέλουμε να μοιραστούμε με άλλους και να ωθούμε μόνον τους θεματικούς κλάδους στους οποίους θέλουμε να συνεργαστούμε.

Αν έχουμε έναν κλάδο με όνομα `serverfix` στον οποίο θέλουμε να δουλέψουμε με άλλους, μπορούμε να τον ωθήσουμε με τον ίδιο τρόπο που ωθήσαμε τον πρώτο μας κλάδο.
Εκτελούμε την εντολή `git push <remote> <branch>`:(((εντολές git, push)))

[source,console]
----
$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -> serverfix
----

Στην πραγματικότητα αυτή η εντολή είναι μία συντόμευση.
Το Git αναπτύσσει αυτόματα το όνομα κλάδου `serverfix` σε `refs/heads/serverfix:refs/heads/serverfix`, που σημαίνει "`Πάρε τον τοπικό μου κλάδο `serverfix` και ώθησέ τον ώστε να ενημερωθεί ο αντίστοιχος κλάδος `serverfix` του απομακρυσμένου διακομιστή`".
Θα δούμε πιο λεπτομερώς το κομμάτι `refs/heads/` στην ενότητα <<ch10-git-internals#ch10-git-internals>>· προς το παρόν μπορούμε να το αγνοήσουμε.
Επίσης μπορούμε να τρέξουμε την εντολή `git push origin serverfix:serverfix`, που κάνει ακριβώς το ίδιο πράγμα -- λέει, "`Πάρε το δικό μου `serverfix` και κάνε τον, το `serverfix` του απομακρυσμένου διακομιστή`".
Χρησιμοποιήσουμε αυτή την εντολή για να ωθήσουμε έναν τοπικό κλάδο σε έναν απομακρυσμένο που έχει διαφορετικό όνομα.
Αν δεν θέλατε να ονομάζεται `serverfix` στο απομακρυσμένο αποθετήριο, τότε μπορούμε να τρέξουμε την εντολή `git push origin serverfix:awesomebranch` ώστε να ωθήσουμε τον τοπικό μας κλάδο `serverfix` στον κλάδο με όνομα `awesomebranch` στο απομακρυσμένο αποθετήριο.

[NOTE]
.Δεν χρειάζεται να γράφουμε τον κωδικό πρόσβασής μας κάθε φορά.
====
Αν θέλουμε να ωθήσουμε κάτι σε ένα URL με HTTPS, ο διακομιστής Git θα μας ζητήσει το όνομα χρήστη και τον κωδικό μας για ταυτοποίηση.
Η προεπιλεγμένη ρύθμιση είναι να μας ζητήσει αυτή την πληροφορία στο τερματικό, ώστε ο διακομιστής να αποφανθεί αν έχουμε το δικαίωμα να ωθήσουμε αλλαγές.

Αν δεν θέλουμε να πληκτρολογούμε τον κωδικό πρόσβασής μας κάθε φορά που ωθούμε κάτι, μπορούμε να ορίσουμε μία "`προσωρινή μνήμη διαπιστευτηρίων`" ("`credential cache`").
Ο πιο απλός τρόπος είναι να παραμένουν στη μνήμη για μερικά λεπτά, κάτι που μπορεί να οριστεί εύκολα με την εντολή `git config --global credential.helper cache`.

Περισσότερες πληροφορίες σχετικά με τις διάφορες επιλογές προσωρινής αποθήκευσης διαπιστευτηρίων βλ. <<ch07-git-tools#r_credential_caching>>.
====

Την επόμενη φορά που κάποιος από τους συνεργάτες μας ανακτήσει δεδομένα από τον διακομιστή, θα πάρει μία αναφορά που θα δείχνει εκεί όπου βρίσκεται ο κλάδος `serverfix` του διακομιστή, δηλαδή κάτω από τον απομακρυσμένο κλάδο `origin/serverfix`:

[source,console]
----
$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -> origin/serverfix
----

Είναι σημαντικό να σημειώσουμε πως όταν εκτελούμε μία εντολή `git fetch`, που φέρνει νέους κλάδους απομακρυσμένης παρακολούθησης στον υπολογιστή μας, δεν έχουμε αυτόματα τοπικά επεξεργάσιμα αρχεία. 
Με άλλα λόγια, σε αυτή την περίπτωση, δεν έχουμε έναν νέο κλάδο `serverfix` -- έχουμε μόνον έναν δείκτη στον `origin/serverfix` που δεν μπορούμε να τροποποιήσουμε.

Για να συγχωνεύσουμε αυτή τη δουλειά στον τρέχοντα κλάδο εργασίας μας, μπορούμε να τρέξουμε την εντολή `git merge origin/serverfix`.
Αν θέλουμε τον δικό μας κλάδο `serverfix` στον οποίο μπορούμε να εργαστούμε, μπορούμε να τον βασίσουμε στον κλάδο απομακρυσμένης παρακολούθησης:

[source,console]
----
$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

Η παραπάνω εντολή μας δίνει έναν τοπικό κλάδο στον οποίο μπορούμε να δουλέψουμε και ξεκινά από το σημείο που βρίσκεται ο κλάδος `origin/serverfix`.

[[r_tracking_branches]]
==== Παρακολούθηση κλάδων

(((κλάδοι, παρακολούθηση)))(((κλάδοι, upstream)))
Όταν κάνουμε checkout έναν τοπικό κλάδο από έναν κλάδο απομακρυσμένης παρακολούθησης, αυτόματα δημιουργείται ένας "`κλάδος παρακολούθησης`" (και ο κλάδος που παρακολουθείται ονομάζεται "`κλάδος upstream`").
Οι κλάδοι παρακολούθησης είναι τοπικοί κλάδοι που σχετίζονται άμεσα με κάποιο απομακρυσμένο κλάδο.
Αν είμαστε σε έναν κλάδο παρακολούθησης και πληκτρολογήσουμε `git pull`, το Git αυτόματα γνωρίζει από ποιον διακομιστή να ανακτήσει και σε ποιον κλάδο να συγχωνεύσει.

Όταν κλωνοποιείτε ένα αποθετήριο, αυτό δημιουργεί αυτόματα έναν κλάδο `master` που παρακολουθεί τον κλάδο `origin/master`.
Όμως μπορούμε να ορίσουμε και άλλους κλάδους παρακολούθησης, αν θέλουμε -- κλάδους που παρακολουθούν κλάδους σε άλλα απομακρυσμένα αποθετήρια ή δεν παρακολουθούν τον κλάδο `master`.
Η πιο απλή περίπτωση είναι αυτή που μόλις είδατε, η εντολή `git checkout -b <branch> <remote>/<branch>`.
Αυτή η περίπτωση είναι τόσο συνηθισμένη που το Git μας παρέχει την επιλογή `--track`:

[source,console]
----
$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

Μάλιστα, είναι τόσο συνηθισμένη που υπάρχει συντόμευση για την παραπάνω επιλογή. 
Αν το όνομα του κλάδου στον οποίο προσπαθείτε να μεταβείτε (α) δεν υπάρχει και (β) έχει το ίδιο όνομα με μόνο έναν απομακρυσμένο, το Git θα δημιουργήσει αυτόματα έναν κλάδο παρακολούθησης.

[source,console]
----
$ git checkout serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

Για να ορίσουμε έναν τοπικό κλάδο με διαφορετικό όνομα από αυτό του απομακρυσμένου κλάδου, μπορούμε εύκολα να χρησιμοποιήσουμε την πρώτη εκδοχή με διαφορετικό όνομα τοπικού κλάδου:

[source,console]
----
$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'
----

Τώρα ο τοπικός μας κλάδος `sf` θα τραβά αυτόματα από τον κλάδο `origin/serverfix`.

Αν έχουμε ήδη έναν τοπικό κλάδο και θέλουμε να τον συνδέσουμε με έναν απομακρυσμένο κλάδο που μόλις τραβήξαμε ή θέλουμε να αλλάξουμε τον κλάδο upstream που παρακολουθούμε, μπορούμε να χρησιμοποιήσουμε την επιλογή `-u` ή `--set-upstream-to` με την εντολή `git branch` ώστε να τον συνδέσουμε οποιαδήποτε στιγμή.

[source,console]
----
$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
----

[NOTE]
.Συντόμευση upstream
====
Όταν έχουμε ορίσει έναν κλάδο παρακολούθησης, μπορούμε να αναφερόμαστε σε αυτόν ως `@{upstream}` ή με τη συντομογραφία `@{u}`.
Άρα αν είμαστε στον κλάδο `master` και αυτός παρακολουθεί τον `origin/master`, μπορούμε να πούμε κάτι σαν `git merge @{u}` αντί για `git merge origin/master`, αν θέλουμε.(((@{u})))(((@{upstream})))
====

Αν θέλουμε να δούμε ποιους κλάδους παρακολούθησης έχουμε ορίσει, μπορούμε να χρησιμοποιήσουμε την επιλογή `-vv` στην εντολή `git branch`.
Αυτή θα παραθέσει όλους τους τοπικούς κλάδους με περισσότερες πληροφορίες, όπως ποιον κλάδο παρακολουθεί κάθε κλάδος και αν ο τοπικός μας κλάδος προηγείται ή υστερεί σε σχέση με τον απομακρυσμένο κλάδο ή και τα δύο.

[source,console]
----
$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] Add forgotten brackets
  master    1ae2a45 [origin/master] Deploy index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] This should do it
  testing   5ea463a Try something new
----

Εδώ μπορούμε να δούμε ότι ο κλάδος μας `iss53` παρακολουθεί τον `origin/iss53` και "`προηγείται`" κατά δύο (ahead 2), δηλαδή έχουμε κάνει δύο υποβολές τοπικά που δεν έχουν ωθηθεί στον διακομιστή. 
Επίσης μπορούμε να δούμε ότι ο τοπικός μας κλάδος `master` παρακολουθεί τον `origin/master` και είναι ενημερωμένος.
Στη συνέχεια βλέπουμε ότι ο κλάδος μας `serverfix` παρακολουθεί τον κλάδο `server-fix-good` στον διακομιστή `teamone` και προηγείται κατά τρεις και υστερεί κατά μία, που σημαίνει ότι υπάρχει μία υποβολή στον διακομιστή που δεν την έχουμε συγχωνεύσει ακόμη και τρεις τοπικές υποβολές που δεν έχουμε ωθήσει ακόμη.
Τέλος, βλέπουμε ότι ο κλάδος μας `testing` δεν παρακολουθεί κανέναν απομακρυσμένο κλάδο.

Είναι σημαντικό να σημειώσουμε ότι αυτοί οι αριθμοί είναι οι υποβολές από την τελευταία φορά που ανακτήσαμε (fetch) από τον κάθε διακομιστή.
Αυτή η εντολή δεν ρωτά τους διακομιστές, απλά μας λέει τι έχει ήδη αποθηκευμένο τοπικά από τους διακομιστές.
Αν θέλουμε εντελώς ενημερωμένους αριθμούς υποβολών με τις οποίες προηγείται και υστερεί ο κλάδος μας, πρέπει να τρέξουμε μία εντολή `fetch` προς όλους τους απομακρυσμένους πριν τρέξουμε την παραπάνω εντολή.
Αυτό μπορούμε να το κάνουμε ως εξής: 

[source,console]
----
$ git fetch --all; git branch -vv
----

==== Ελκυσμοί

(((ελκυσμός)))(((pulling)))
Ενώ η εντολή `git fetch` ανακτά όλες τις αλλαγές που δεν έχουμε ήδη από τον διακομιστή, δεν θα αλλάξει τον κατάλογο εργασίας μας καθόλου.
Απλά θα πάρει τα δεδομένα και θα μας αφήσει να τα συγχωνεύσουμε μόνοι μας.
Πάντως, υπάρχει η εντολή `git pull` η οποία ουσιαστικά στις περισσότερες περιπτώσεις είναι μία εντολή `git fetch` που ακολουθείται από μία εντολή `git merge`.
Αν έχουμε ορίσει κάποιον κλάδο παρακολούθησης όπως σας δείξαμε στην προηγούμενη ενότητα, είτε με ρητό ορισμό είτε επειδή τον έχουμε δημιουργήσει με τις εντολές `clone` ή `checkout`, η `git pull` θα αναζητήσει τον διακομιστή και κλάδο τον οποίο παρακολουθεί ο τρέχων κλάδος μας, θα ανακτήσει από τον διακομιστή και θα προσπαθήσει να συγχωνεύσει σε αυτό τον απομακρυσμένο κλάδο.

[[r_delete_branches]]
==== Διαγραφή απομακρυσμένων κλάδων

(((κλάδοι, διαγραφή απομακρυσμένων)))
Ας υποθέσουμε ότι τελειώσαμε με τον απομακρυσμένο κλάδο -- π.χ. οι συνεργάτες μας και εσείς τελειώσαμε με ένα χαρακτηριστικό και το έχουμε συγχωνεύσει στον κλάδο `master` του απομακρυσμένου αποθετηρίου (ή τέλος πάντων σε οποιονδήποτε κλάδο υπάρχει η ευσταθής έκδοσή του έργου μας).
Μπορούμε να διαγράψουμε τον απομακρυσμένο κλάδο χρησιμοποιώντας την επιλογή `--delete` στην εντολή `git push`.
Αν θέλουμε να διαγράψουμε τον κλάδο `serverfix` από τον διακομιστή, τρέχουμε τα παρακάτω:

[source,console]
----
$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix
----

Βασικά αυτό που κάνει αυτή η εντολή είναι να απομακρύνει τον δείκτη από τον διακομιστή.
Ο διακομιστής Git γενικά θα διατηρήσει τα δεδομένα εκεί για λίγο καιρό, μέχρι να τρέξει μία διαδικασία συλλογής σκουπιδιών (garbage collection) ώστε αν ο κλάδος διαγράφηκε κατά λάθος, να είναι εύκολο να αποκατασταθεί.
